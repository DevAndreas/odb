<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
  <title>C++ Object Persistence with ODB</title>

  <meta name="copyright" content="&copy; 2009-2010 Code Synthesis Tools CC"/>
  <meta name="keywords" content="odb,c++,object,persistence,ORM,relational,database,RDBMS,ODBMS,OODBMS"/>
  <meta name="description" content="C++ Object Persistence with ODB"/>
  <meta name="revision" content="1.0"/>
  <meta name="version" content="1.0.0"/>

  <link rel="stylesheet" type="text/css" href="default.css" />

<style type="text/css">
  pre {
    padding    : 0 0 0 0em;
    margin     : 0em 0em 0em 0;

    font-size  : 102%
  }

  body {
    min-width: 48em;
  }

  h1 {
    font-weight: bold;
    font-size: 200%;
    line-height: 1.2em;
  }

  h2 {
    font-weight : bold;
    font-size   : 150%;

    padding-top : 0.8em;
  }

  h3 {
    font-size   : 140%;
    padding-top : 0.8em;
  }

  /* Adjust indentation for three levels. */
  #container {
    max-width: 48em;
  }

  #content {
    padding: 0 0.1em 0 4em;
    /*background-color: red;*/
  }

  #content h1 {
    margin-left: -2.06em;
  }

  #content h2 {
    margin-left: -1.33em;
  }

  /* Title page */

  #titlepage {
    padding: 2em 0 1em 0;
    border-bottom: 1px solid black;
  }

  #titlepage .title {
    font-weight: bold;
    font-size: 200%;
    text-align: center;
    padding: 1em 0 2em 0;
  }

  #titlepage p {
    padding-bottom: 1em;
  }

  #titlepage #revision {
    padding-bottom: 0em;
  }

  /* Lists */
  ul.list li, ol.list li {
    padding-top      : 0.3em;
    padding-bottom   : 0.3em;
  }

  div.img {
    text-align: center;
    padding: 2em 0 2em 0;
  }

  /*  */
  dl dt {
    padding   : 0.8em 0 0 0;
  }

  /* TOC */
  table.toc {
    border-style      : none;
    border-collapse   : separate;
    border-spacing    : 0;

    margin            : 0.2em 0 0.2em 0;
    padding           : 0 0 0 0;
  }

  table.toc tr {
    padding           : 0 0 0 0;
    margin            : 0 0 0 0;
  }

  table.toc * td, table.toc * th {
    border-style      : none;
    margin            : 0 0 0 0;
    vertical-align    : top;
  }

  table.toc * th {
    font-weight       : normal;
    padding           : 0em 0.1em 0em 0;
    text-align        : left;
    white-space       : nowrap;
  }

  table.toc * table.toc th {
    padding-left      : 1em;
  }

  table.toc * td {
    padding           : 0em 0 0em 0.7em;
    text-align        : left;
  }

  /* operators table */
  #operators {
    margin: 2em 0 2em 0;

    border-collapse   : collapse;
    border            : 1px solid;
    border-color      : #000000;

    font-size        : 11px;
    line-height      : 14px;
  }

  #operators th, #operators td {
    border: 1px solid;
    padding           : 0.9em 0.9em 0.7em 0.9em;
  }

  #operators th {
    background : #cde8f6;
  }

  #operators td {
    text-align: left;
  }

</style>


</head>

<body>
<div id="container">
  <div id="content">

  <div class="noprint">

  <div id="titlepage">
    <div class="title">C++ Object Persistence with ODB</div>

    <p>Copyright &copy; 2009-2010 Code Synthesis Tools CC</p>

    <p>Permission is granted to copy, distribute and/or modify this
    document under the terms of the
    <a href="http://www.codesynthesis.com/licenses/fdl-1.3.txt">GNU Free
    Documentation License, version 1.3</a>; with no Invariant Sections,
    no Front-Cover Texts and no Back-Cover Texts.</p>

    <!-- REMEMBER TO CHANGE VERSIONS IN THE META TAGS ABOVE! -->
    <p id="revision">Revision 1.0, September 2010</p>
    <p>This revision of the manual describes ODB 1.0.0 and is available
    in the following formats:
    <a href="http://www.codesynthesis.com/products/odb/doc/manual.xhtml">XHTML</a>,
    <a href="http://www.codesynthesis.com/products/odb/doc/odb-manual.pdf">PDF</a>, and
    <a href="http://www.codesynthesis.com/products/odb/doc/odb-manual.ps">PostScript</a>.</p>
  </div>

  <h1>Table of Contents</h1>

  <table class="toc">

  </table>
  </div>

  <!-- Hello World Example -->


  <h1><a name="2">2 Hello World Example</a></h1>

  <p>In this chapter we will examine how to create a simple C++
     application that relies on ODB for object persistence using
     the traditional "Hello World" example. In particular, we will
     discuss how to declare persistent classes, generate database
     support code, as well as compile and run our application. We
     will also learn how to make objects persistent, load, update
     and delete persistent objects, as well as query the database
     for persistent objects that match a certain criteria.</p>

  <p>The code presented in this chapter is based on the
     <code>hello</code> example which can be found in the
     <code>odb-examples</code> package of the ODB distribution.</p>

  <h2><a name="2.1">2.1 Declaring a Persistent Class</a></h2>

  <p>In our "Hello World" example we will depart slighly from
     the norm and say hello to people instead of the world. People
     in our application will be represented as objects of C++ class
     <code>person</code> which is saved in <code>person.hxx</code>:</p>

  <pre class="c++">
// person.hxx
//

#include &lt;string>

class person
{
public:
  person (const std::string&amp; first,
          const std::string&amp; last,
          unsigned short age);

  const std::string&amp;
  first () const;

  const std::string&amp;
  last () const;

  unsigned short
  age () const;

  void
  age (unsigned short);

private:
  std::string first_;
  std::string last_;
  unsigned short age_;
};
  </pre>

  <p>In order not to miss anyone whom we need to greet, we would like
  to save the person objects in a database. To achive this we declare
  the <code>person</code> class as persistent:</p>

  <pre class="c++">
// person.hxx
//

#include &lt;string>

#include &lt;odb/code.hxx>     // (1)

#pragma db object           // (2)
class person
{
  ...

private:
  person () {}              // (3)

  friend class odb::access; // (4)

  #pragma db id auto        // (5)
  unsigned long id_;        // (5)

  std::string first_;
  std::string last_;
  unsigned short age_;
};
  </pre>

  <p>To be able to save person objects in the database we had to make
     five changes, marked with (1) to (5), to the orignal class
     definition. The first change is the inclusion of the ODB
     headers <code>core.hxx</code>. This headers provides a number
     of core ODB declarations, such as <code>odb::access</code>, that
     are used to define peristent classes.</p>

  <p>The second change is the addition of <code>db object</code>
     pragma just before the class definition. This pragma tells the
     ODB compiler that the class that follows is persistent. Note
     that making a class persistent does not mean that all objects
     of this class will automatiacally be stored in the database.
     You would still create ordinary or <em>transient</em> instances
     of this class just as you would before. The difference is that
     now you can make such transient instances persistent, as we will
     see shortly.</p>

  <p>The third change is the addition of the default constructor.
     The ODB-generated database support code will use this constructor
     when instantiating an object from the persistent state. As we have
     done for the <code>person</code> class, you can make the default
     constructor private or protected if you don't want to make it
     available to the ordinary users of your class.</p>

  <p>With the fourth change we make the <code>odb::access</code> class
     friend of our <code>person</code> class. This is necessary to make
     the default constructor and the data members accessible to the
     ODB support code. If your class has public default constructor and
     public data members, then the <code>friend</code> declaration is
     unnecessary.</p>

  <p>The final change adds a data member called <code>id_</code> which
     is preceded by another pragma. In ODB every persistent object must
     have a unique, within its class, identifier. Or, in other words,
     no two persistent instances of the same type have equal
     identifiers. For our class we use an integer id. The
     <code>db id auto</code> pragma that preceeds the <code>id_</code>
     member tells the ODB compiler that the following member is the
     object's id. The <code>auto</code> specifier indicates that it is
     a database-assigned id. A unique id will be automatically generated
     by the database and assigned to the object when it is made
     persistent.</p>

  <p>In this example we choose to add an identifier because none of
     the existing members could serve the same purpose. However, if
     a class already has a member with suitable properties, then it
     is natural to use that member for an identifier. For example,
     if our <code>person</code> class contained some form of personal
     identification (SSN in the United States or ID/passport number
     in other countries), then we could use that as an id. Or, if
     we stored an email associated with each person, then we could
     have used that since each person is presumed to have a unqiue
     email address:</p>

  <pre class="c++">
class person
{
  ...

  #pragma db id
  std::string email_;

  std::string first_;
  std::string last_;
  unsigned short age_;
};
  </pre>

  <p>Now that we have the header file with the persistent class, let's
     see how to generate that database support code that we talked
     about.</p>

  <h2><a name="2.2">2.2 Generating Database Support Code</a></h2>

  <p>The persistent class definition that we created in the previous
     section was particularly light on code that could actualy
     do the job and store the person't data to a database. There
     was no serialization or deserialization code, not even data member
     registration, that you would normally have to write by hand in
     other ORM libraries for C++. This is because in ODB code
     that translates between the database and C++ representations
     of an object is automatically generated by the ODB compiler.</p>

  <p>To compile the <code>person.hxx</code> header we created in the
     previous section and generate the support code for the MySQL
     database we invoke the ODB compiler from a terminal (UNIX) or
     a command prompt (Windows):</p>

  <pre class="terminal">
odb -d mysql --generate-query person.hxx
  </pre>

  <p>We will use MySQL in the reminder of this chapter though other
     supported database systems can be used instead.</p>

  <p>If you haven't installed the common ODB runtime library
     (<code>libodb</code>) or installed it into a directory where
     the C++ compiler doesn't search for headers by default,
     then you may get the following error:</p>

  <pre class="terminal">
person.hxx:10:24: fatal error: odb/core.hxx: No such file or directory
  </pre>

  <p>To resolve this you will need to specify <code>libodb</code> headers
     location with the <code>-I</code> preprocessor option, for example:</p>

  <pre class="terminal">
odb -I.../libodb -d mysql --generate-query person.hxx
  </pre>

  <p>Here <code>.../libodb</code> represents the path to the
     <code>libodb</code> directory.</p>

  <p>The above invocation of the ODB compiler produces three C++ files:
     <code>person-odb.hxx</code>, <code>person-odb.ixx</code>,
     <code>person-odb.cxx</code>. You normally don't use types
     or functions contained in these files directly. Rather, all
     you have to do is include <code>person-odb.hxx</code> in
     C++ files where you are performing database operations
     with classes from <code>person.hxx</code> as well as compile
     <code>person-odb.cxx</code> and link the resulting object
     file to your application.</p>

  <p>You may be wondering what is the <code>--generate-query</code>
     option for. It instructs the ODB compiler to generate
     optional query support code that we will use later in our
     "Hello World" example. Another option that we will find
     useful is <code>--generate-schema</code>. This option
     makes the ODB compiler generate a fourth file,
     <code>person.sql</code>, which contains the database
     schema for the classes defined in <code>person.hxx</code>:</p>

  <pre class="terminal">
odb -d mysql --generate-query --generate-schema person.hxx
  </pre>


  <p>If you would like to see the list of all the available options,
     refer to the <a href="http://www.codesynthesis.com/products/odb/doc/odb.xhtml">ODB
     Compiler Command Line Manual</a>.</p>


  <p>Now that we have the persistent class and the database support
     code, the only part that is left is the application code that
     does something useful with all this. But before we move on to
     the fun part, let first learn how to build and run an application
     that uses ODB. This way when we have some application code
     to try, there are no more delays before we can run it.</p>

  <h2><a name="2.3">2.3 Compiling and Running</a></h2>

  <p>Assuming that the <code>main()</code> function with some application
     code is saved in <code>driver.cxx</code> and the database support
     code and schema are generated as described in the previous section,
     to build our application we will first need to compile all the C++
     source files and then link them with two ODB runtime libraries.</p>

  <p>On UNIX, the compilation part can be done with the following commands
     (for Microsoft Visual Studio setup, see the <code>odb-examples</code>
     package):</p>

  <pre class="terminal">
c++ -c driver.cxx
c++ -c person-odb.cxx
  </pre>

  <p>Similar to the ODB compilation, if you get an error stating that
  a headers in <code>odb/</code> or <code>odb/mysql</code> directory
  in not found. In this case you will need to use the <code>-I</code>
  preprocessor option to specify the location of the common ODB runtime
  library (<code>libodb</code>) and MySQL ODB runtime library
  (<code>libodb-mysql</code>).</p>

  <p>Once the compilation is done, we can link the application with
  the following command:</p>

  <pre class="terminal">
c++ -o driver driver.o person-odb.o -lodb-mysql -lodb
  </pre>

  <p>Notice that we link our application with two ODB libraries:
    <code>libodb</code> which is a common runtime library and
    <code>libodb-mysql</code> which is a MySQL runtime library
    (if you use another database, then the name of this library
    will change accordingly). If you get an error saying that
    one of these libraries could not be found, then you will need
    to use the <code>-L</code> linker option to specify their locations.</p>

  <p>Before we can run our application we need to create a database
    schema using the generated <code>person.sql</code> file. For MySQL
    we can use the <code>mysql</code> client program, for example:</p>

  <pre class="terminal">
mysql --user=odb_test --database=odb_test &lt; person.sql
  </pre>

  <p>The above command will login to a local MySQL server as user
    <code>odb_test</code> without a password and use database
    named <code>odb_test</code>. Note that after executing this
    command all data stored in the <code>odb_test</code> database
    will be deleted.</p>

  <p>Once the database schema is ready, we run our application
  using the same login and database name:</p>

  <pre class="terminal">
./driver --user odb_test --database odb_test
  </pre>


  <h2><a name="2.4">2.4 Making Objects Persistent</a></h2>

  <p>Now that we have the infrastructure work out of the way, it
  is time to see our first code fragment that interracts with the
  database. In this section we will learn how to make <code>person</code>
  objects persistent:</p>

  <pre class="c++">
// driver.cxx
//

#include &lt;memory>   // std::auto_ptr
#include &lt;iostream>

#include &lt;odb/database.hxx>
#include &lt;odb/transaction.hxx>

#include &lt;odb/mysql/database.hxx>

#include "person.hxx"
#include "person-odb.hxx"

using namespace std;
using namespace odb;

int
main (int argc, char* argv[])
{
  try
  {
    auto_ptr&lt;database> db (new mysql::database (argc, argv));

    unsigned long john_id, jane_id, joe_id;

    // Create a few persistent person objects.
    //
    {
      person john ("John", "Doe", 33);
      person jane ("Jane", "Doe", 32);
      person joe ("Joe", "Dirt", 30);

      transaction t (db->begin_transaction ());

      db->persist (john);
      db->persist (jane);
      db->persist (joe);

      t.commit ();

      // Save object ids for later use.
      //
      john_id = john.id ();
      jane_id = jane.id ();
      joe_id = joe.id ();
    }
  }
  catch (const odb::exception&amp; e)
  {
    cerr &lt;&lt; e.what () &lt;&lt; endl;
    return 1;
  }
}
  </pre>

  <p>Let's examine this code piece by piece. At the beginnig we include
     a bunch of headers. Those include <code>odb/database.hxx</code> and
     <code>odb/transaction.hxx</code> which define database
     system-independant <code>odb::database</code> and
     <code>odb::transaction</code> interfaces. Then we include
     <code>odb/mysql/database.hxx</code> which defines the
     MySQL implementation of the <code>database</code> interface. Finaly,
     we include <code>person.hxx</code> and <code>person-odb.hxx</code>
     which define our persistent <code>person</code> class.</p>

  <p>Once we are in <code>main()</code>, the first thing we do is create
     the MySQL database object. Notice that this is the last line in
     <code>driver.cxx</code> that mentions MySQL explicitly; the rest
     of the code works though the common interfaces and is database
     system-independant. We use the <code>argc</code>/<code>argv</code>
     <code>mysql::database</code> constructor which automatically
     extract the database parameters, such as login name, passowrd,
     database name, etc., from the command line. In your own applications
     you may prefer to use other variants of the <code>mysql::database</code>
     constructor which allow you to pass this information directly
     (@@ ref MySQL database).</p>

  <p>Next we create three <code>person</code> objects. Right now they are
     transient objects, which means that if we terminate the application
     at this point, they will be gone without any evidence of them ever
     existed. The next line starts a database transaction. We discuss
     transactions in detail later in this manual. For now all we need
     to know is that all ODB database operations must be performed within
     a transaction and that a transaction is an atomic unit of work; all
     database operations performed within a transaction either succeed
     (commited) together or are automatically undone (rolled back).</p>

  <p>Once we are in a transaction, we call the <code>persist()</code>
     database function on each of our <code>person</code> objects.
     At this point the state of each object is saved in the database.
     However, note that this state is not permanent until and unless
     the transaction is commited. If, for example, our application
     crashes at this point, there will still be no evidence of our
     objects ever existed.</p>

  <p>In our case one more thing happens when we call <code>persist()</code>
     on a <code>person</code> object. Remember that we decided to use
     database-assigned identifiers for our objects. The call to
     <code>persist()</code> is where this assignment happens. Once
     this function returns, the <code>id_</code> member contains this
     object's unique identifier.</p>

  <p>After we have persisted our objects, it is time to commit the
     transaction and make the changes permanent. Only after the
     <code>commit()</code> function returns succefully are we
     guaranteed that the objects are made persistent. Following
     the crashing example, if our application terminates after
     the commit for whatever reason, the objects' state in the
     database will remain intact. In fact, as we will discover
     shortly, our application can be restarted and load the
     orignal objects from the database. Note also that a
     transaction must be commited explicitly with the
     <code>commit()</code> call. If the <code>transaction</code>
     object leaves scope without the transaction beeing
     explicitly commited or rolled back, it will be automatically
     rolled back. This behavior allows you not to worry about
     exceptions being thrown within a transaction; if they
     cross the transaction boundaries, the transaction will
     be automatically rolled back and all the changes made
     to the database undone.</p>

  <p>After the transaction has been commited, we save the persistent
     objects' ids in local variables. We will use them later in this
     chapter to perform other database operations on our persistent
     objects. You might have noticed that our <code>person</code>
     class doesn't have the <code>id()</code> function that we use
     here. To make our code work we need to add a simple accessor
     with this name that returns the value of the <code>id_</code>
     data member.</p>

  <p>The final bit of code in our example is the <code>catch</code>
     block that handles the ODB exceptions. We do this by catching
     the base ODB exception and printing the diagnostics. (@@ Ref
     exceptions)</p>

  <p>Let's now compile (see @@ Ref "Compiling and Running") and then
     run our first ODB application:</p>

  <pre class="terminal">
mysql --user=odb_test --database=odb_test &lt; person.sql
./driver --user odb_test --database odb_test
  </pre>

  <p>Our first application doesn't print anything except for error
     messages so we can't really tell whether it actually stored the
     objects' state in the database. While we will extend our application
     to be more enternaining, for now we can use the <code>mysql</code>
     client to examine the database content. It will also give us a feel
     for how the object are stored:</p>

  <pre class="terminal">
mysql --user=odb_test --database=odb_test

Welcome to the MySQL monitor.

mysql> select * from person;

+----+-------+------+-----+
| id | first | last | age |
+----+-------+------+-----+
|  1 | John  | Doe  |  33 |
|  2 | Jane  | Doe  |  32 |
|  3 | Joe   | Dirt |  30 |
+----+-------+------+-----+
3 rows in set (0.00 sec)

mysql> quit
  </pre>

  <p>In the next section we will examine how to query the database
     for persistent objects matching a certain criteria.</p>

  <h2><a name="2.4">2.4 Querying Database for Objects</a></h2>

  <p>So far our application doesn't resemble a typical "Hello World"
     example. It doesn't print anything except for error messages.
     Let's change that and teach our application to say hello to
     people from our database. To make it a bit more interesting,
     let's say hello only to people over 30:</p>

  <pre class="c++">
// driver.cxx
//

...

int
main (int argc, char* argv[])
{
  try
  {
    ...

    // Create a few persistent person objects.
    //
    {
      ...
    }

    typedef odb::query&lt;person> query;
    typedef odb::result&lt;person> result;

    // Say hello to those over 30.
    //
    {
      transaction t (db->begin_transaction ());

      result r (db->query&lt;person> (query::age > 30));

      for (result::iterator i (r.begin ()); i != r.end (); ++i)
      {
        cout &lt;&lt; "Hello, " &lt;&lt; i->first () &lt;&lt; "!" &lt;&lt; endl;
      }

      t.commit ();
    }
  }
  catch (const odb::exception&amp; e)
  {
    cerr &lt;&lt; e.what () &lt;&lt; endl;
    return 1;
  }
}
  </pre>

  <p>The first half of our application is the same as before and is
     replaced with "..." in the above listing for brievety. Again, let's
     examine the rest of it piece by piece.</p>

  <p>The two <code>typedef</code>s create convenient aliases for two
     template instantiations that will be used a lot in our application.
     The first is the query type for the <code>person</code> objects
     and the second is the result type of that query.</p>

  <p>Then we begin a new transaction and call the <code>query()</code>
     database function. We pass a query expression
     (<code>query::age > 30</code>) which limits the returned objects
     only to those with age greater than 30. We also save the result
     of the query in a local variable.</p>

  <p>The next few lines perform a pretty standard for-loop iteration
     over the result sequence printing hello for every returned person.
     Then we commit the transaction and we are node. Let's see what
     this application will print:</p>

  <pre class="terminal">
mysql --user=odb_test --database=odb_test &lt; person.sql
./driver --user odb_test --database odb_test

Hello, John!
Hello, Jane!
  </pre>


  <p>That looks about right but how do we know that the query actually
     used the database instead of just using some in-memory artifacts of
     the earlier <code>persist()</code> calls. One way to test this
     would be to comment out the first transaction in our application
     and re-run it without re-creating the database schema so that the
     objects that were persisted during the previous run will be returned.
     Alternatively, we can just re-run the same application without
     re-creating the schema and notice that we now how duplicate
     objects:</p>

  <pre class="terminal">
./driver --user odb_test --database odb_test

Hello, John!
Hello, Jane!
Hello, John!
Hello, Jane!
  </pre>

  <p>What happens here is that the previous run of our application
     persisted a set of <code>person</code> objects and when we re-run
     the application, we persist another set with the same names but
     with different id. When we later run the query, matches from
     both sets are returned. We can change the line where we print
     the "Hello" string as follows to illustrate this point:</p>

  <pre class="c++">
cout &lt;&lt; "Hello, " &lt;&lt; i->first () &lt;&lt; " (" &lt;&lt; i->id () &lt;&lt; ")!" &lt;&lt; endl;
  </pre>

  <p>If we now re-run this modified program, we will get the following
     output:</p>

  <pre class="terminal">
./driver --user odb_test --database odb_test

Hello, John (1)!
Hello, Jane (2)!
Hello, John (4)!
Hello, Jane (5)!
Hello, John (7)!
Hello, Jane (8)!
  </pre>

  <p>The identifiers 3, 6, and 9 that miss from the above list belong to
     the "Joe Dirt" objects which are not selected by this query.</p>

  <h2><a name="2.5">2.5 Updating Persistent Objects</a></h2>

  <p>While making objects persistent and then selecting some of them using
     queries ara two useful operations, most applications will also need
     to change the object's state and then make these changes persistent.
     Let's illustrate this by updating Joe's age who just had a birthday:</p>

  <pre class="c++">
// driver.cxx
//

...

int
main (int argc, char* argv[])
{
  try
  {
    ...

    unsigned long john_id, jane_id, joe_id;

    // Create a few persistent person objects.
    //
    {
      ...

      // Save object ids for later use.
      //
      john_id = john.id ();
      jane_id = jane.id ();
      joe_id = joe.id ();
    }

    // Joe Dirt just had a birthday, so update his age.
    //
    {
      transaction t (db->begin_transaction ());

      auto_ptr&lt;person> joe (db->load&lt;person> (joe_id));
      joe->age (joe->age () + 1);
      db->store (*joe);

      t.commit ();
    }

    // Say hello to those over 30.
    //
    {
      ...
    }
  }
  catch (const odb::exception&amp; e)
  {
    cerr &lt;&lt; e.what () &lt;&lt; endl;
    return 1;
  }
}
  </pre>

  <p>The beginning and the end of this transaction are the same as
     the previous two. Once within a transaction, we call the
     <code>load()</code> database function to instantiate a
     <code>person</code> object with Joe's persistent state. We
     pass Joe's object identifer that we stored earlier when we
     made this object persistent.</p>

  <p>With the instantiated object in hand we increment the age
     and call the <code>store()</code> database function to update
     the object's state in the database. Once the transaction is
     commited, the changes are made permanent in the database.</p>

  <p>If we now run this application, we will see Joe in the output
     since he is now over 30:</p>

  <pre class="terminal">
mysql --user=odb_test --database=odb_test &lt; person.sql
./driver --user odb_test --database odb_test

Hello, John!
Hello, Jane!
Hello, Joe!
  </pre>

  <p>What if we didn't have an identifier for Joe? Maybe this object
     was made persisted in another run of our application or by another
     application altogether. Provided that we have only one Joe Dirt
     in the database, we can use the query facility to come up with
     an alternative implementation of the above transaction:</p>

  <pre class="c++">
    // Joe Dirt just had a birthday, so update his age. An
    // alternative implementation without using the object id.
    //
    {
      transaction t (db->begin_transaction ());

      result r (db->query&lt;person> (query::first == "Joe" &amp;&amp;
                                   query::last == "Dirt"));

      result::iterator i (r.begin ());

      if (i != r.end ())
      {
        auto_ptr&lt;person> joe (*i);
        joe->age (joe->age () + 1);
        db->store (*joe);
      }

      t.commit ();
    }
  </pre>

  <h2><a name="2.5">2.5 Deleting Persistent Objects</a></h2>

  <p>The last operation that we will discuss in this chapter is deleting
     the persistent object from the database. The following code
     fragment shows how we can delete an object given its identifier:</p>

  <pre class="c++">
    // John Doe is no longer in our database.
    //
    {
      transaction t (db->begin_transaction ());
      db->erase&lt;person> (john_id);
      t.commit ();
    }
  </pre>

  <p>To delete John from the database we start a transaction, call
     the <code>erase()</code> database function with John's object
     id, and commit the transaction. After the transaction is commited
     the erased object is no longer persistent.</p>

  <p>If we don't have an object id handy, we can use queries to find
     and delete the object:</p>

  <pre class="c++">
    // John Doe is no longer in our database. An alternative
    // implementation without using the object id.
    //
    {
      transaction t (db->begin_transaction ());

      result r (db->query&lt;person> (query::first == "John" &amp;&amp;
                                   query::last == "Doe"));

      result::iterator i (r.begin ());

      if (i != r.end ())
      {
        auto_ptr&lt;person> john (*i);
        db->erase (*john);
      }

      t.commit ();
    }
  </pre>

  <h2><a name="2.5">2.5 Summary</a></h2>

  <p>This chapter presented a very simple application which, nevertheless,
     excercised all core database functions: <code>persist()</code>,
     <code>query()</code>, <code>load()</code>, <code>store()</code>,
     and <code>erase()</code>. We also saw that writing an application
     that uses ODB involves the following steps:</p>

  <ol>
    <li>Declare persistent classes in header files.</li>
    <li>Compile these headers to generate database support code.</li>
    <li>Link the application with the support code and two ODB runtime libraries.</li>
  </ol>



  <p>Do not be concerned if, at this point, much appears unclear. The intent
     of this chapter is to give you only a general idea of how to persist C++
     objects with ODB. We will cover all the details throughout the remainder
     of this manual.</p>


  <h1><a name="3">3 Working Title</a></h1>

  <p>@@</p>

  <p>In this chapter we will continue to use and exapand the
     <code>person</code> persistent class that we have developed in the
     previous chapter.</p>

  <h2><a name="3.1">3.1 Base Concepts</a></h2>

  <p>The term <em>database</em> can refer to three distinct things:
     a general notion of a place where an application stores its data,
     a software implementation for managing this data (for example
     MySQL), and, finally, some database software implementations
     may manage several data stores which are usually distinguished
     by name. This name is also commonly referred to as database.</p>

  <p>In this manual, when we use just the word <em>database</em>, we
     refer to the first meaning above, for example,
     "The <code>store()</code> function saves the object's state to
     the database." The term Database Management System (DBMS) is
     often used to refer to the second meaning of the words database.
     In this manual we will use the term <em>database system</em>
     for short, for example, "Database system-independant
     application code." Finally, to distinguish the third meaning
     from the other two we will use the term <em>database name</em>,
     for example, "The second option specfies the database name
     that the application should use to store its data."</p>

  <p>In C++ there is only one notion of a type and an instance
     of a type. For example, a fundamental type, such as <code>int</code>,
     is, for the most part, treated the same as a user defined class
     type. However, when it comes to persistence, we have to place
     certain restrictions and requirements on certain C++ types that
     can be stored in the database. As a result, we devide persistent
     C++ types into two groups: <em>object types</em> and <em>value
     types</em>. An stances of an object type is called an <em>object</em>
     and an instance of a value type &mdash; a <em>value</em>.</p>

  <p>An object is an independant entity. It can be stored, updated,
     and deleted in the database independant of other objects or values.
     An object has an identifier, called <em>object id</em>, that is
     unique among all instances of an object type within a database.
     An object consits of data members which are either values or
     references to other objects. In contrast, a value can only be
     stored in the database as part of an object and doesn't have
     its own unique identifier.</p>

  <p>An object type is a C++ class. Because of this one to one
     relationship, we will use terms <em>object type</em>
     and <em>object class</em> interchangably. In contrast,
     a value type can be a fundamental C++ type, such as
     <code>int</code> or a class type, such as <code>std::string</code>.
     If a value consists of other values then is is called a
     <em>composite value</em> and its type &mdash; a
     <em>composite value type</em>. Otherwise the the value is
     called <em>simple value</em> and its type &mdash; a
     <em>simple value type</em>. Note that the distinction between
     simple and composite values is conceptual rather than
     representational. For example, <code>std::string</code>
     is a simple value type because conceptually string is a
     single value even though the representation of the string
     class may contain several data member each of which would be
     considered a value. In fact, the same value type can be
     viewed (and mapped) as both simple and composite by different
     applications.</p>

  <p>Seeing how all these concepts map to the relational model
     will hopefully make these distinctions more clear. In a relational
     database an object type is mapped to a table and a value type is
     mapped to one or more columns. A simple value type is mapped
     to a single column while a composite value type is mapped to
     several columns. Conversly, an object is stored as a row in this
     table and a value is stored as one or more cells in this row.
     A simple value is stored in a single cell while a composite
     value occupies several cells.</p>

  <p>Going back to the distinction beetween simple and composite
     values, consider a date type which has three integer data
     members: year, month, and day. In one application it can be
     conidered a composite value and each member will get its
     own column in the relational database. In another application
     it can considered as a simple value and stored a single
     column as a number of day from some predefined date.</p>

  <p>Until now, we have been using the term <em>persistent class</em>
     to refer to object classes. We will continue to do so even though
     a value type can also be a class. The reason for this assimetry
     is the subordinate nature of value types when it comes to
     database operations. Remember that values are never stored
     directly but rather as part of an object that contains them.
     As a result, when we say that we want to make a C++ class
     persistent or persist an instance of a class in the database,
     we invariably refer to an object class rather than a value
     class.</p>

  <p>To make a C++ class a persistent object class we need to declare
     it as such using the <code>db object</code> pragma:</p>

  <pre class="c++">
    #pragma db object
    class person
    {
      ...
    };
  </pre>

  <p>The other pargma that we need to use is the <code>db id</code>
     which designates one of the data members as an object id:</p>

  <pre class="c++">
    #pragma db object
    class person
    {

    private:
      #pragma db id
      unsigned long id_;
    };
  </pre>

  <p>These two pragmas are the minimum required to declare a
     persistent class. Other pragmas can be used to fine-tune
     the persistence-related properties of a class and its
     members.</p>

  <p>You may be wondering whether we aslo have to do declare value types
     as persistent. We don't need to do anything special for simple value
     types such as <code>int</code> or <code>std::string</code> since the
     ODB compiler knows how to map them to the database system types and
     how to convert between the two. On the other hand, if a simple value
     is unknown to the ODB compiler then you will need to provide the
     mapping to the database system type and, possibly, the code to
     convert between the two. For more information on this see @@ Ref
     Custom value types/pragma value type. Composite value types are
     not yet supported by ODB and will not discuss them further in
     this revision of the manual.</p>

  <p>Normally, you would use object types to model real-world entities,
     things that have their own identity. For example, in the
     previous chapter we created a <code>person</code> class to model
     a person which is a real-world enitity. Name and age, which we
     used as data members in our <code>person</code> class are clearly
     values. It is hard to think of age 31 or name "Joe" as having their
     own identity.</p>

  <p>A good test to determine whether something is an object or
     a value is to consider if other objects might reference
     it. A person is clearly an object because it can be refered
     to by other object's such as a spouce, an employer, or a
     bank. On the other hand, a person's age or name is not
     something that other objects would normally refer to.</p>

  <p>Also, when an object represents a real entity, it is easy to
     choose a suitable object identifier. For example, for a
     person there is an established notion of an identifier
     (SSN, student id, passport number, etc). Another alternative
     is to use person't email address as an identifier.</p>

  <p>Note, however, that these are only guidelines. There could
     be goot reasons to make something that would normally be
     a value an object. Consider, for example, a database that
     stores a vast number of people. Many of the person objects
     in this database have the same names and surnames and the
     overhead of repeating them in every object may negatively
     affect the performance. In this case we could make first name
     and last name each an object and only store references to
     these objects in the <code>person</code> class.</p>

  <p>An instance of a persistent class can be in one of two states:
    <em>transient</em> and <em>persistent</em>. A transient
    instance only has a representation in the applciation's
    memory and will ceas to exist when the application terminates
    unless it is explicitly made persistent. A persistent instance
    has a representation in both the application's memory and the
    database. A persistent instance will remain even after the
    application terminates unless and until it is explicitly
    deleted from the database. In other words, a transient instance
    of a persistent class behaves just like an instance of any
    ordinary C++ class.</p>


  <h2><a name="3.2">3.2 Database</a></h2>

  <p>Before an application can make use of a persistence services
     offered by ODB, it has to create a database instance. A
     database instance is the representation of the place where
     the application stores its persistent objects. You create
     a database instance by instantiating one of the database
     system-specific classes. For example <code>odb::mysql::database</code>
     would be such a class for the MySQL database system. You will
     also normally pass a database name as an argument to the
     <code>database</code> class' constructor. The following
     code fragment shows how we can create a database instance
     for the MySQL database system:</p>

  <pre class="c++">
  #include &lt;odb/database.hxx>
  #include &lt;odb/mysql/database.hxx>

  auto_ptr&lt;odb::database> db (
    new odb::mysql::database (
      "test_user"     // database login name
      "test_password" // database password
      "test_database" // database name
      ));
  </pre>

  <p>The <code>odb::database</code> class is an abstract base class
     that defines a common interface for all database system-specific
     classes provided by ODB. You would normally work with the database
     instance via this interface unless there is a specific
     functionality that your application depends on and which is
     only exposed by a particular system's <code>database</code>
     class.</p>

  <p>The <code>odb::database</code> interface defines functions for
     starting transactions and manipulating persistent objects.
     These are discussed in detail in the reminder of this chapter
     as well as the next chapter which is dedicated to the topic of
     querying the database for persistent objects. For details on the
     system-specific <code>database</code> classes, refer for
     (@@ ref Database Systems).</p>

  <h2><a name="3.3">3.3 Transactions</a></h2>

  <p>A transaction is an atomic, consistent, isolated and durable
     (ACID) unit of work. All database operations can only be
     performed within a transaction and each thread of execution
     in an application can have only one active transaction at a
     time.</p>

  <p>By atomicity we mean that when it comes to making changes to
     the database state within a transaction,
     either all the changes succeed or none at all. Consider,
     for example, a transaction that transfers funds between two
     objects representing bank accounts. If the debit function
     on the first object succeeds but the credit function on
     the second fails, the transaction is rolled back and the
     database state of the first object remains unchanged.</p>

  <p>By consistency we mean that a transaction must take all the
     objects stored in the database from one consistent state
     to another. For example, if a bank account object must
     reference a person object as its owner and we forget to
     set this reference before making the object persistent,
     the transaction will be rolled back and the database
     will remain unchanged.</p>

  <p>By isolation we mean that the changes made to the database
     state during a transaction are only visible inside this
     transaction until and unless it is commited. Using the
     above example with bank transfer, the results of the
     debit operation performed on the first object is not
     visible to other transactions until the credit operation
     is successfully completed and the transaction is commited.</p>

  <p>By durability we mean that once the transaction is committed,
     the changes that it made to the database state are permanent
     and will survive failures such as an application crash. From
     now the only way to alter this state is to execute and commit
     another transaction.</p>

  <p>A transaction is started by calling the
     <code>database::begin_transaction()</code>
     function. The returned transaction handle is stored in
     an instance of the <code>odb::transaction</code> class which is
     defined in the <code>odb/transaction.hxx</code> header file.
     A source code fragment that uses ODB transactions should include
     this header file. The <code>odb::transaction</code> class has
     the following interface:</p>

  <pre class="c++">
namespace odb
{
  class transaction
  {
  public:
    typedef odb::database database_type;

    void
    commit ();

    void
    rollback ();

    database_type&amp;
    database ();

    static transaction&amp;
    current ();

    static bool
    has_current ();
  };
}
  </pre>

  <p>The <code>commit()</code> function commits a transaction and
     <code>rollback()</code> rolls it back. Unless the transaction
     has been <em>finalized</em>, (explicitly commited or rolled back),
     the destructor of the <code>odb::transaction</code> class will
     automatically roll it back when the transaction instance goes
     out of scope.</p>

  <p>The <code>database()</code> function returns the database this
     transaction is working on. The <code>current()</code> static
     function returns the currently active transaction for this
     thread. If there is no active transaction, this function
     throws the <code>odb::not_in_transaction</code> exception.
     You can check whether there is a transaction in effect using
     the <code>has_current()</code> static function.</p>

  <p>If two or more transaction access or modify more than one object
     and are executed concurrently by different applications or by
     different threads within the same application, then it is possible
     that these transactions will try to access objects in an incompatible
     order and deadlock. The canonical example of a deadlock are
     two transactions in which the first has modified <code>object1</code>
     and is waiting for the second transaction to commit its changes to
     <code>object2</code> so that it can update <code>object2</code>. At
     the same time the second transaction has modified <code>object2</code>
     and is waiting for the first transaction to commit its changes to
     <code>object1</code> because it also needs to modify <code>object1</code>.
     As a result none of the two transactions can complete.</p>

  <p>The database system detects such situations and automatically
     aborts the waiting operation in one of the deadlocked transactions.
     In ODB this translates to the <code>odb::deadlock</code> exception
     being thrown from one of the database functions. You would normally
     handle a deadlock by restarting the transaction, for example:</p>

  <pre class="c++">
for (;;)
{
  try
  {
    transaction t (db.begin_transaction ());

    ...

    t.commit ();
    break;
  }
  catch (const odb::deadlock&amp;)
  {
    continue;
  }
}
  </pre>

  <p>Note that in the above discussion of atomicity, consistency,
     isolation, and durability, all of these guarantees only apply
     to the object's state in the database as opposed to the object's
     state in the application's memory. It is possible to roll
     a transaction back but still have changes from this
     transaction in the application's memory. An easy way to
     avoid this potentiall inconsistency is to instantiate
     persistent objects withing the transaction's scope. Consider,
     for example, this two implementations of the same transaction:</p>

  <pre class="c++">
void
update_age (database&amp; db, person&amp; p)
{
  transaction t (db.begin_transaction ());

  p.age (p.age () + 1);
  db.store (p);

  t.commit ();
}
  </pre>

  <p>In the above implementation, if the <code>store()</code> call fails
     and the transaction is rolled back, the state of the person
     object in the database and the state of the same object in the
     application's memory will differ. Now consider an
     alternative implementation which only instantiates the
     person object for the duration of the transaction:</p>

  <pre class="c++">
void
update_age (database&amp; db, unsigned long id)
{
  transaction t (db.begin_transaction ());

  auto_ptr&lt;person> p (db.load&lt;person> (id));
  p.age (p.age () + 1);
  db.store (p);

  t.commit ();
}
  </pre>

  <p>Of course, it may be not always be possible to write the
     application in this style. Oftentimes we need to access and
     modify application's state of persistent objects out of
     transactions. In this case it may make sense to try to
     roll back the changes made to the application state if
     the transaction was rolled back and the database state
     remains unchanged. One way to do this is to re-load
     the object's state from the database:</p>

  <pre class="c++">
void
update_age (database&amp; db, person&amp; p)
{
  try
  {
    transaction t (db.begin_transaction ());

    p.age (p.age () + 1);
    db.store (p);

    t.commit ();
  }
  catch (...)
  {
    transaction t (db.begin_transaction ());
    db.load (p.id (), p);
    t.commit ();

    throw;
  }
}
  </pre>


  <h2><a name="3.4">3.4 Making Objects Persistent</a></h2>

  <p>A newly created instance of a persistent class is transient.
     We use the <code>database::persist()</code> function template
     to make a transient instance persistent. This function has two
     overloaded variants with the following signatures:</p>

  <pre class="c++">
  template &lt;typename T>
  typename object_traits&lt;T>::id_type
  persist (const T&amp; object);

  template &lt;typename T>
  typename object_traits&lt;T>::id_type
  persist (T&amp; object);
  </pre>

  <p>The first <code>persist()</code> variant expects a constant reference
     to an instance being persisted and is used on objects with
     application-assigned object ids (@@ref pragma id/auto). The second
     variant expects an unrestricted reference and, if the object id is
     assigned by the database, it updates the passed instance's id member
     with the assigned value. Both variants return the object id of the
     newly persistent object.</p>

  <p>If the database already contains an object of this type with this
     id, the <code>persist()</code> functions throw the
     <code>odb::object_already_persistent</code> exception. This should
     never happen for database-assigned object ids as long as the
     number of objects persisted does not exceed the value space of
     the id type.</p>

  <p>When calling the <code>persist()</code> function we don't need to
     explicitly specify the template type since it will be automatically
     deduced from the argument being passed. The <code>odb::object_traits</code>
     template used in the signature above is part of the database support
     code generated by the ODB compiler.</p>

  <p>The following example shows how we can call this function:</p>

<pre class="c++">
person john ("John", "Doe", 33);
person jane ("Jane", "Doe", 32);

transaction t (db->begin_transaction ());

db->persis (john);
unsigned long jane_id (db->persist (jane));

t.commit ();

cerr &lt;&lt; "Jane's id: " &lt;&lt; jane_id &lt;&lt; endl;
</pre>

  <p>Notice that in the above code fragment we have created instances
     that we were planning to make persistent before starting the
     transaction. Likewise, we printed Jane's id after we have commited
     the transaction. As a general rule, you should avoid performing
     operations within a transaction's scope that can be performed
     before the transaction starts or after it terminates. An active
     transaction consumes both your application's resources, such as
     a database connection, as well as the database server's
     resources, such as object locks. By following the above rule you
     make sure these resources are made available to other threads
     in your application and to other applications for as long as
     possible.</p>

  <h2><a name="3.5">3.5 Loading Persistent Objects</a></h2>

  <p>Once an object is made persistent, and you know its object id, it
     can loaded by the application using the <code>database::load()</code>
     function template. This function has two overloaded variants with
     the following signatures:</p>

  <pre class="c++">
  template &lt;typename T>
  typename object_traits&lt;T>::pointer_type
  load (const typename object_traits&lt;T>::id_type&amp; id);

  template &lt;typename T>
  void
  load (const typename object_traits&lt;T>::id_type&amp; id, T&amp; object);
  </pre>

  <p>Given an object id, the first variant allocates a new instance
     of the object class in the dynamic memory, loads its state from
     the database, and returns the pointer to the new instance. The
     second variant loads the object's state into an existing instance.
     Both functions throw <code>odb::object_not_persistent</code> if
     there is no object of this type with this id in the database.</p>

  <p>When we call the first variant of <code>load()</code> we need to
     explicitly specify the object type. We don't need to do this for
     the second variant because the object type will be automatically
     deduced from the second argument, for example:</p>

  <pre class="c++">
transaction t (db->begin_transaction ());

person* jane (db->load&lt;person> (jane_id));

db->load (jane_id, *jane);

t.commit ();
  </pre>

  <p>If we don't know for sure whether an object with a gived id
     is persistent, we can use the <code>find()</code> function
     instead of <code>load()</code>:</p>

  <pre class="c++">
  template &lt;typename T>
  typename object_traits&lt;T>::pointer_type
  find (const typename object_traits&lt;T>::id_type&amp; id);

  template &lt;typename T>
  bool
  find (const typename object_traits&lt;T>::id_type&amp; id, T&amp; object);
  </pre>

  <p>If an object with this id is not found in the database, the first
     variant of <code>find()</code> returns a <code>NULL</code> pointer
     while the second variant leaves the passed instance unmodified and
     returns <code>false</code>.</p>

  <p>If we don't know an object's identifier, then we can use queries to
     find the object (or objects) matching some other criteria (@@ ref
     query). Note, however, that loading an object's state using its
     identifier can be significantly faster that doing a query.</p>


  <h2><a name="3.5">3.5 Updating Persistent Objects</a></h2>

  <p>If a persistent object has been modified, we can store the updated
     state in the database using the <code>database::update()</code>
     function template:</p>

  <pre class="c++">
  template &lt;typename T>
  void
  update (const T&amp; object);
  </pre>

  <p>If the object passed to this function does not exist in the
     database, <code>update()</code> throws the
     <code>odb::object_not_persistent</code> exception.</p>

  <p>Below is an example of the funds transfer that we talked about
     in the earlier section on transactions. It uses the hypothetical
     <code>bank_account</code> persistent class:</p>

  <pre class="c++">
void
transfer (database&amp; db,
          unsigned long from_acc,
          unsigned long to_acc,
          unsigned int amount)
{
  bank_account from, to;

  transaction t (db.begin_transaction ());

  db.load (from_acc, from);

  if (from.balance () &lt; amount)
    throw insufficient_funds ();

  db.load (to_acc, to);

  to.balance (to.balance () + amount);
  from.balance (from.balance () - amount);

  db.update (to);
  db.update (from);

  t.commit ();
}
  </pre>

  <h2><a name="3.6">3.6 Deleting Persistent Objects</a></h2>

  <p>To delete a persistent object's state from the database we use the
     <code>database::erase()</code> function template. If the application
     still has an instance of the erased object, this instance becomes
     transient. The <code>erase()</code> function has the following
     overloaded variants:</p>

  <pre class="c++">
  template &lt;typename T>
  void
  erase (const T&amp; object);

  template &lt;typename T>
  void
  erase (const typename object_traits&lt;T>::id_type&amp; id);
  </pre>

  <p>The first variant uses an object itself to delete its state from
     the database. The second variant uses the object id to identify
     the object to be deleted. If the object to be deleted does not
     exist in the database, both variants throw the
     <code>odb::object_not_persistent</code> exception.</p>


  <p>We have to specify the object type when calling the second variant
     of <code>erase()</code>. The same is unnecessary for the first
     variant because the object type will be automomatically deduced
     from its argument. The following example shows how can call
     this function:</p>

  <pre class="c++">
const person&amp; john = ...

transaction t (db->begin_transaction ());

db->erase (john);
db->erase&lt;person> (jane_id);

t.commit ();
  </pre>

  <h1><a name="4">4 Querying the Database</a></h1>

  <p>If you don't know the identifiers of the objects that you are looking
     for, you can use queries to search the database for objects matching
     a certain criteria. ODB provides flexible and powerful query support
     that offers two distinct levels of abstraction from the database
     system query language such as SQL.</p>

  <p>At the high level you are presented with an easy to use yet powerful
     object oriented query language, called ODB query language. This
     query language is modeled after and is integrated into C++ allowing
     you to write expressive and safe queries that look and feel like
     plain C++. We have already seen examples of these queries in the
     introductory chapters. Below is another, more interesting, example:</p>

  <pre class="c++">
  typedef odb::query&lt;person> query;
  typedef odb::result&lt;person> result;

  unsigned short age;
  query q (query::first == "John" &amp;&amp; query::age &lt; query::_ref (age));

  for (age = 10; age &lt; 100; age += 10)
  {
    result r (db->query&lt;person> (q));
    ...
  }
  </pre>

  <p>At the low level, queries can be written as predicates using
     the database system-native query language such as the
     <code>WHERE</code> predicate from the SQL <code>SELECT</code>
     statement. This language will be refered to as native query
     language. At this level ODB still takes care of converting
     query parameters from C++ to the database system format. Below
     is the re-implementation of the above example using SQL as
     the native query language:</p>

  <pre class="c++">
  query q ("first = 'John' AND age = " + query::_ref (age));
  </pre>

  <p>Note that at this level you also loose the static typing of
     query expressions. For example, if we wrote something like this:</p>

  <pre class="c++">
  query q (query::first == 123 &amp;&amp; query::agee &lt; query::_ref (age));
  </pre>

  <p>We would get two errors during the C++ compilation. The first would
     indicate that we cannot compare <code>query::first</code> to an
     integer and the second would pick the misspelling in
     <code>query::agee</code>. On the other hand, if we wrote something
     like this:</p>

  <pre class="c++">
  query q ("first = 123 AND agee = " + query::_ref (age));
  </pre>

  <p>It would compile without any errors and would trigger an error
     only when executed by the the database system.</p>

  <p>You are also allowed to combine the two query languages in a single
     query, for example:</p>

  <pre class="c++">
  query q ("first = 'John'" + (query::age &lt; query::_ref (age)));
  </pre>


  <h2><a name="4.1">4.1 ODB Query Language</a></h2>

  <p>An ODB query is an expression that tell the database system whether
     any given object matches our criteria. As such a query expression
     always evaluates to <code>true</code> or <code>false</code>. At
     the higher lever, an expression consist of other expressions
     combined with logical operators such as <code>&amp;&amp;</code> (AND),
     <code>||</code> (OR), and <code>!</code> (NOT). For example:</p>

  <pre class="c++">
  typedef odb::query&lt;person> query;

  query q (query::first == "John" || query::age == 31);
  </pre>

  <p>At the core of every query expression lie simple expressions which
     involve one or more object data members, values, or parameters. To
     refer to an object member you use an expression such as
     <code>query::first</code> above. The names of members in the
     <code>query</code> class are derived from the names of data members
     in the object class by removing the common member name decorations,
     such as leading and trailing underscores, the <code>m_</code> prefix,
     etc.</p>

  <p>In a simple expressions an object member can be compared to a value,
     parameter, or another member using a number of predefined operators
     and functions. The following table gives an overview of the available
     expressions:</p>

  <!-- border="1" is necessary for html2ps -->
  <table id="operators" border="1">
    <tr>
      <th>Operator</th>
      <th>Description</th>
      <th>Example</th>
    </tr>

    <tr>
      <td><code>==</code></td>
      <td>equal</td>
      <td><code>query::age == 31</code></td>
    </tr>

    <tr>
      <td><code>!=</code></td>
      <td>unequal</td>
      <td><code>query::age != 31</code></td>
    </tr>

    <tr>
      <td><code>&lt;</code></td>
      <td>less than</td>
      <td><code>query::age &lt; 31</code></td>
    </tr>

    <tr>
      <td><code>></code></td>
      <td>greater than</td>
      <td><code>query::age > 31</code></td>
    </tr>

    <tr>
      <td><code>&lt;=</code></td>
      <td>less than or equal</td>
      <td><code>query::age &lt;= 31</code></td>
    </tr>

    <tr>
      <td><code>>=</code></td>
      <td>greater than or equal</td>
      <td><code>query::age >= 31</code></td>
    </tr>

    <tr>
      <td><code>in()</code></td>
      <td>one of the values</td>
      <td><code>query::age.in (30, 32, 34)</code></td>
    </tr>

    <tr>
      <td><code>in_range()</code></td>
      <td>one of the values in range</td>
      <td><code>query::age.in_range (begin, end)</code></td>
    </tr>

    <tr>
      <td><code>is_null()</code></td>
      <td>value is NULL</td>
      <td><code>query::age.is_null ()</code></td>
    </tr>

    <tr>
      <td><code>is_not_null()</code></td>
      <td>value is not NULL</td>
      <td><code>query::age.is_not_null ()</code></td>
    </tr>
  </table>

  <p>The operator precedence in the query expressions are the same
     as for equivalent C++ operators. You can use parentheses to
     make sure the expression is evaluated in the desired order.
     For example:</p>

  <pre class="c++">
  query q ((query::first == "John" || query::first == "Jane") &amp;&amp;
           query::age &lt; 31);
  </pre>



  <h2><a name="4.2">4.2 Parameter Binding</a></h2>

  <p>An instance of the <code>odb::query</code> class encapsulates two
     parts of information about the query: the query expression and
     the query parameters. Parameters can be bound to C++ variables
     either by value or by reference.</p>

  <p>If a parameter is bound by value, then the value for this parameter
     is copied from the C++ variable to the query instance at the query
     construction time. On the other hand, if a parameter is bound by
     reference, then the query instance only stores a reference to the
     bound variable. The actual value for the parameter is only extracted
     at the query execution time. Consider, for example the following
     two queries:</p>

  <pre class="c++">
  string name ("John");

  query q1 (query::first == query::_val (name));
  query q2 (query::first == query::_ref (name));

  name = "Jane";

  db->query&lt;person> (q1); // Find John.
  db->query&lt;person> (q2); // Find Jane.
  </pre>

  <p>The <code>odb::query</code> class provides two special functions,
     <code>_val()</code> and <code>_ref()</code>, that allow you to
     bind the parameter either by value or by reference, respectively.
     In the embedded query language, if the binding is not specified
     explicitly, the value semantics is used by default. In the
     native query language, binding must always be specified
     explicitly. For example:</p>

  <pre class="c++">
  query q1 (query::age &lt; age);                // By value.
  query q2 (query::age &lt; query::_val (age));  // By value.
  query q3 (query::age &lt; query::_ref (age));  // By reference.

  query q4 ("age &lt; " + age);                  // Error.
  query q5 ("age &lt; " + query::_val (age));    // By value.
  query q6 ("age &lt; " + query::_ref (age));    // By reference.
  </pre>

  <p>A query that only has by-value parameters does not depend on any
     other variables and is self-sufficient once constructed. A query
     that has one or more by-reference parameter depends on the
     bound variables until the query is executed. If one such variable
     goes out of scope and you execute the query, the behavior is
     undefined.</p>

  <h2><a name="4.3">4.3 Executing a Query</a></h2>

  <p>Once we have the query instance ready and by-reference parameters
     initialized, we can execute the query using the
     <code>database::query()</code> function template. It has two
     overloaded variants:</p>

  <pre class="c++">
  template &lt;typename T>
  result&lt;T>
  query (bool cache = true);

  template &lt;typename T>
  result&lt;T>
  query (const odb::query&lt;T>&amp;, bool cache = true);
  </pre>

  <p>The first variant is used to return all persistent objects of a
     given type stored in the database. The second variant uses the
     passed query instance to only return objects matching the
     query criteria. The <code>cache</code> argument determines
     whether the object states should be cached in the application's
     memory or if it should be returned by the database system
     one by one as the iteration over the result progresses. The
     result caching is discussed in detail in the next section.</p>

  <p>When calling the <code>query()</code> function we have to
     explicitly specify the object type we are querying. For example:</p>

  <pre class="c++">
  typedef odb::query&lt;person> query;
  typedef odb::result&lt;person> result;

  result all (db->query&lt;person> ());
  result johnes (db->query&lt;person> (query::first == "John"));
  </pre>

  <p>Note that it is not required to explicitly create a named
     query variable before executing it. For example, the following
     two queries are equivalent:</p>

  <pre class="c++">
  query q (query::first == "John");

  result r1 (db->query&lt;person> (q));
  result r1 (db->query&lt;person> (query::first == "John"));
  </pre>

  <p>Normally you would create a named query instance if you are
     planning to run the same query multiple times and would use the
     in-line version for those that are executed only once.</p>

  <p>It is also possible to create queries from other queries by
     combinding them using logical operators. For example:</p>

  <pre class="c++">
result
find_minors (database&amp; db, const query&amp; name_query)
{
  return db.query&lt;person> (name_query &amp;&amp; query::age &lt; 18);
}

result r (find_underage (db, query::first == "John"));
  </pre>

  <h2><a name="4.3">4.3 Query Result</a></h2>

  <p>The result of executing a query is zero, one, or more objects
     matching the query criteria. The result is represented as the
     <code>odb::result</code> class template:</p>

  <pre class="c++">
  typedef odb::query&lt;person> query;
  typedef odb::result&lt;person> result;

  result johnes (db->query&lt;person> (query::first == "John"));
  </pre>

  <p>It is best to view an instance of <code>odb::result</code>
     as a handle to a stream, such as a file stream. While you can
     make a copy of a result or assign one result to another, the
     two instances will refer to the same result stream. Advancing
     the current position in one instance will also advance it in
     another. The result instance is only usable within a transaction
     it was created in. Trying to manipulate the result after the
     transaction has terminates leads to undefined behavior.</p>

  <p>The <code>odb::result</code> class template conforms to the
     standard C++ sequence requirements and has the following
     interface:</p>

  <pre class="c++">
namespace odb
{
  template &lt;typename T>
  class result
  {
  public:
    typedef odb::result_iterator&lt;T> iterator;

  public:
    result ();

    result (const result&amp;);

    result&amp;
    operator= (const result&amp;);

    void
    cache ();

    iterator
    begin ();

    iterator
    end ();
  };
}
  </pre>

  <p>The default constructor creates an empty result set. The
    <code>cache()</code> function caches the returned objects'
    state in the application's memory. We have already mentioned
    result caching when we talked about query execution. As you
    may remember the <code>database::query()</code> function
    cahces the result unless instructed not to by the caller.
    The <code>result::cache()</code> function allows you to
    cache the result at a later stage if it wasn't already
    cached during query execution.</p>

  <p>If result is cached, the entire state of the returned
     objects is stored in the application's memory. Note that
     the actual objects are still only instantiated on demand
     during result iteration. It is the raw database state that
     is cached in memory. In contrast, for uncached results
     the object state is sent by the database system one object
     at a time as the iteration progresses.</p>

  <p>Uncached results can improve performance of both the application
     and the database system in situations where you have a large
     number of objects in the result or if you will only examine
     a small portion of the returned objects. However, uncached
     results have a number of limitations. There can only be one
     uncached result in a transaction. Creating another result
     (cached or uncached) by calling <code>database::query()</code>
     will invalidate the first uncached result. Furthermore,
     executing any other database function, such as <code>update()</code>
     or <code>erase()</code> will also invalidate the uncached result.</p>

  <p>To iterate over the objects in a result we use the
     <code>begin()</code> and <code>end()</code> functions
     together with the <code>odb::result&lt;T>::iterator</code>
     type, for example:</p>

  <pre class="c++">
  result r (db->query&lt;person> (query::first == "John"));

  for (result::iterator i (r.begin ()); i != r.end (); ++i)
  {
    ...
  }
  </pre>

  <p>The result iterator is an input iterator which means that the
     only two position operations that are support are to move to the
     next object and determine whether we have reached the end of the
     result stream. In fact, the result iteraror can only be in two
     states: the current position and the end position. If you have
     two iterators pointing to the current position and then you
     advance one of them, the other will advance as well. This,
     for example, means that it doesn't make sense to store an
     iterator that points to some object of interest in the result
     stream with the intent of dereferncing it after the iteration
     is over. Instead, you would need to store the object itself.</p>

  <p>The result iterator has the following dereference functions
     that can be used to access the pointed-to object:</p>

  <pre class="c++">
namespace odb
{
  template &lt;typename T>
  class result_iterator
  {
  public:
    T*
    operator-> () const;

    T&amp;
    operator* () const;

    typename object_traits&lt;T>::pointer_type
    load ();

    void
    load (T&amp; x);
  };
}
  </pre>

  <p>When you call the <code>*</code> or <code>-></code> operator,
     the iterator will allocate a new instance of the object class
     in the dynamic memory, load its state from the returned database
     state, and return a reference or pointer to the new instance. The
     iterator maintains the ownership of the returned object and will
     return the same pointer for subsequent calls to either of these
     operators until it is advanced to the next object or you call
     the first overloaded variant of the <code>load()</code>
     function (see below). For example:</p>

  <pre class="c++">
  result r (db->query&lt;person> (query::first == "John"));

  for (result::iterator i (r.begin ()); i != r.end ();)
  {
    cout &lt;&lt; i->last () &lt;&lt; endl; // Create an object.
    person&amp; p (*i);             // Reference to the same object.
    cout &lt;&lt; p.age () &lt;&lt; endl;
    ++i;                        // Free the object.
  }
  </pre>

  <p>The <code>result_iterator::load()</code> function is similar to
     <code>database::load()</code>. The first overloaded variant
     returns a dynamically allocated instance of the current
     object which you are responsible for deleting. As an optimization,
     if the iterator already owns an object as result of the earlier
     call to the <code>*</code> or <code>-></code> operator, then it
     relinquishes the ownership of this object and returns it instead.
     This allows you to write code like this without worrying about
     a double allocation:</p>

  <pre class="c++">
  result r (db->query&lt;person> (query::first == "John"));

  for (result::iterator i (r.begin ()); i != r.end (); ++i)
  {
    if (i->last == "Doe")
    {
      auto_ptr p (i.load ());
      ...
    }
  }
  </pre>

  <p>Note, however, that because of this optimization, a subsequent to
     <code>load()</code> call to the <code>*</code> or <code>-></code>
     operator results in the allocation of a new object.</p>

  <p>The second variant of the <code>result_iterator::load()</code>
     function allows you to load the current object's state into an
     existing instance. For example:</p>

  <pre class="c++">
  result r (db->query&lt;person> (query::first == "John"));

  person p;
  for (result::iterator i (r.begin ()); i != r.end (); ++i)
  {
    i.load (p);
    cout &lt;&lt; p.last () &lt;&lt; endl;
    cout &lt;&lt; i.age () &lt;&lt; endl;
  }
  </pre>

  </div>
</div>


</body>
</html>
