<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
  <title>C++ Object Persistence with ODB</title>

  <meta name="copyright" content="&copy; 2009-2010 Code Synthesis Tools CC"/>
  <meta name="keywords" content="odb,c++,object,persistence,ORM,relational,database,RDBMS,ODBMS,OODBMS"/>
  <meta name="description" content="C++ Object Persistence with ODB"/>
  <meta name="revision" content="1.0"/>
  <meta name="version" content="1.0.0"/>

  <link rel="stylesheet" type="text/css" href="default.css" />

<style type="text/css">
  pre {
    padding    : 0 0 0 0em;
    margin     : 0em 0em 0em 0;

    font-size  : 102%
  }

  body {
    min-width: 48em;
  }

  h1 {
    font-weight: bold;
    font-size: 200%;
    line-height: 1.2em;
  }

  h2 {
    font-weight : bold;
    font-size   : 150%;

    padding-top : 0.8em;
  }

  h3 {
    font-size   : 140%;
    padding-top : 0.8em;
  }

  /* Adjust indentation for three levels. */
  #container {
    max-width: 48em;
  }

  #content {
    padding: 0 0.1em 0 4em;
    /*background-color: red;*/
  }

  #content h1 {
    margin-left: -2.06em;
  }

  #content h2 {
    margin-left: -1.33em;
  }

  /* Title page */

  #titlepage {
    padding: 2em 0 1em 0;
    border-bottom: 1px solid black;
  }

  #titlepage .title {
    font-weight: bold;
    font-size: 200%;
    text-align: center;
    padding: 1em 0 2em 0;
  }

  #titlepage p {
    padding-bottom: 1em;
  }

  #titlepage #revision {
    padding-bottom: 0em;
  }

  /* Lists */
  ul.list li, ol.list li {
    padding-top      : 0.3em;
    padding-bottom   : 0.3em;
  }

  div.img {
    text-align: center;
    padding: 2em 0 2em 0;
  }

  /*  */
  dl dt {
    padding   : 0.8em 0 0 0;
  }

  /* TOC */
  table.toc {
    border-style      : none;
    border-collapse   : separate;
    border-spacing    : 0;

    margin            : 0.2em 0 0.2em 0;
    padding           : 0 0 0 0;
  }

  table.toc tr {
    padding           : 0 0 0 0;
    margin            : 0 0 0 0;
  }

  table.toc * td, table.toc * th {
    border-style      : none;
    margin            : 0 0 0 0;
    vertical-align    : top;
  }

  table.toc * th {
    font-weight       : normal;
    padding           : 0em 0.1em 0em 0;
    text-align        : left;
    white-space       : nowrap;
  }

  table.toc * table.toc th {
    padding-left      : 1em;
  }

  table.toc * td {
    padding           : 0em 0 0em 0.7em;
    text-align        : left;
  }

  /* operators table */
  #operators {
    margin: 2em 0 2em 0;

    border-collapse   : collapse;
    border            : 1px solid;
    border-color      : #000000;

    font-size        : 11px;
    line-height      : 14px;
  }

  #operators th, #operators td {
    border: 1px solid;
    padding           : 0.9em 0.9em 0.7em 0.9em;
  }

  #operators th {
    background : #cde8f6;
  }

  #operators td {
    text-align: left;
  }

  /* specifiers table */
  #specifiers {
    margin: 2em 0 2em 0;

    border-collapse   : collapse;
    border            : 1px solid;
    border-color      : #000000;

    font-size        : 11px;
    line-height      : 14px;
  }

  #specifiers th, #specifiers td {
    border: 1px solid;
    padding           : 0.9em 0.9em 0.7em 0.9em;
  }

  #specifiers th {
    background : #cde8f6;
  }

  #specifiers td {
    text-align: left;
  }

  /* mapping table */
  #mapping {
    margin: 2em 0 2em 0;

    border-collapse   : collapse;
    border            : 1px solid;
    border-color      : #000000;

    font-size        : 11px;
    line-height      : 14px;
  }

  #mapping th, #mapping td {
    border: 1px solid;
    padding           : 0.9em 0.9em 0.7em 0.9em;
  }

  #mapping th {
    background : #cde8f6;
  }

  #mapping td {
    text-align: left;
  }

</style>


</head>

<body>
<div id="container">
  <div id="content">

  <div class="noprint">

  <div id="titlepage">
    <div class="title">C++ Object Persistence with ODB</div>

    <p>Copyright &copy; 2009-2010 Code Synthesis Tools CC</p>

    <p>Permission is granted to copy, distribute and/or modify this
    document under the terms of the
    <a href="http://www.codesynthesis.com/licenses/fdl-1.3.txt">GNU Free
    Documentation License, version 1.3</a>; with no Invariant Sections,
    no Front-Cover Texts and no Back-Cover Texts.</p>

    <!-- REMEMBER TO CHANGE VERSIONS IN THE META TAGS ABOVE! -->
    <p id="revision">Revision 1.0, September 2010</p>
    <p>This revision of the manual describes ODB 1.0.0 and is available
    in the following formats:
    <a href="http://www.codesynthesis.com/products/odb/doc/manual.xhtml">XHTML</a>,
    <a href="http://www.codesynthesis.com/products/odb/doc/odb-manual.pdf">PDF</a>, and
    <a href="http://www.codesynthesis.com/products/odb/doc/odb-manual.ps">PostScript</a>.</p>
  </div>

  <h1>Table of Contents</h1>

  <table class="toc">

  </table>
  </div>

  <h1><a name="0">Preface</a></h1>

  <p>As more and more aspects of our lives become increasinly dependant
     on software systems, more and more applications are required to
     save the data they work on in persistent storage. Database
     management systems and, in particular, relational database
     management systems (RDBMS) are a common answer to this requirement.
     However, while the application development techniques have evolved
     significantly over the past decades, the relational databases stayed
     relatively unchanged. In particular, this led to the now famous
     mismatch between the object-oriented models used by many modern
     applications and the relational models still used by RDBMS.</p>

  <p>While relational databases may be inconvenient to use from modern
     programming languages, they are still the only rational choice for
     many applications due to their maturity, reliability, as well as
     the avaliability of tools and alternative implementations.</p>

  <p>To allow application developers to utilize relational databases
     from their object-oriented applications, a technique called
     object-relational mapping (ORM) is often used. It involves
     conversion between objects in the application's memory and
     their relational representation in the database. While
     object-relational mapping can be done manually, automated ORM
     systems are available for most programming languages. ODB is
     an ORM system for C++.</p>

  <h2><a name="0.1">About This Document</a></h2>

  <p>The goal of this manual is to provide you with an understanding
     of the object persistence model as implemented by ODB and to
     allow you to efficiently evaluate it against your project's
     technical requirements. As such, this document is intended for
     C++ application developers and software architects who are looking
     for a C++ object persistence solution. Prior experience with C++
     is required to understand this document. Basic understanding of
     relational database systems is advantageous but not expected
     or required.</p>


  <h2><a name="0.2">More Information</a></h2>

  <p>Beyond this manual, you may also find the following sources of
     information useful:</p>

  <ul class="list">
    <li><a href="http://www.codesynthesis.com/products/odb/doc/odb.xhtml">ODB
        Compiler Command Line Manual</a></li>

    <li>The <code>INSTALL</code> files in the ODB source packages provide
        build instructions for various platforms.</li>

    <li>The <code>odb-examples</code> package contains a collection of
        examples and a README file with an overview of each example.</li>

    <li>The <a href="http://www.codesynthesis.com/mailman/listinfo/odb-users">odb-users</a>
        mailing list is the place to ask technical questions about ODB.
        Furthermore, the
        <a href="http://www.codesynthesis.com/pipermail/odb-users/">archives</a>
        may already have answers to some of your questions.</li>

  </ul>


  <!-- CHAPTER -->


  <h1><a name="1">1 Introduction</a></h1>

  <p>ODB is an object-relational mapping (ORM) system for C++. It provides
     tools, APIs, and library support that allow you to persist C++ objects
     to a relational database (RDBMS) without having to deal with tables,
     columns, or SQL and without manually writing any of the mapping code.</p>

  <p>ODB is highly flexible and customizable. It can either completely
     hide the relational nature of the underlying database or expose
     some of the details as required. For example, you can automatically
     map basic C++ types to suitable SQL types, generate the relational
     database schema for your persistent clases, and use simple, safe,
     and yet powerful object query language instead of SQL. Or you can
     assign SQL types to individual data members, use the existing
     database schema, and run native SQL <code>SELECT</code> queries.</p>

  <p>ODB is not a framework. It does not dictate how you should write
     your application. Rather it is designed to fit into your
     style and architecture by only handling object persistence
     and not interfering with any other functionality. There is
     no common base type that all persistent classes should derive
     from nor there are any restrictions on the data member types
     in persistent classes. Existing classes can be made persistent
     with little or nor modifications.</p>

  <p>ODB has been designed for high performance and low memory
     overhead. Prepared statements are used to send and receive
     object state in binary format instead of text which reduces
     the load on the application and the database server. Extensive
     caching of connections, prepared statements, and buffers saves
     time and resources on connection establishment, statement parsing
     and memory allocations. For each supported database system the
     native C API is used instead of ODBC or higher-level wrapper
     APIs to reduce overhead and provide the most efficient implementation
     for each database operation. Finally, persistent classes have
     zero memory overhead. There are no hidden "database" members
     that each class must have nor there are per-object data structures
     allocated by ODB.</p>

  <p>In this chapter we present a high-level overview of ODB. We will
     start with the ODB architecture in <a href="#1.1">Section 1.1</a>.
     <a href="#1.2">Section 1.2</a> will then outline the workflow of
     building an application that uses ODB. We will conclude this
     chapter with <a href="#1.3">Section 1.3</a> that discusses the
     drawbacks of the traditional way of saving C++ objects to
     relational databases and benefits of using ODB for object
     persistence. The next chapter takes the more hands-on approach
     and shows the concrete steps necessary to implement object
     persistence in a "Hello World" application.</p>

  <h2><a name="1.1">1.1 Architecture and Workflow</a></h2>

  <p>From the application developer's perspective ODB
     consist of three main components: the ODB compiler, the common
     runtime library, called <code>libodb</code>, and the
     database-specific runtime libraries, called
     <code>libodb-&lt;databse></code> where &lt;databse> is
     the name of the database system  this runtime
     is for, for example, <code>libodb-mysql</code>. For instance,
     if the application is going to use the MySQL database for
     object persistence, then the three ODB components that this
     application will use are the ODB compiler, <code>libodb</code>
     and <code>libodb-mysql</code>.</p>

  <p>The ODB compiler generates the database support code for
     persistent classes in your application. The input to the ODB
     compiler is one or more C++ header files defining C++ classes
     that you want to make persistent. For each input header file
     the ODB compiler generates a set of C++ source files implementing
     conversion between persistent C++ classes defined in this
     header and their database representation. The ODB compiler
     can also generate a database schema file that creates tables
     necessary to store the persistent classes.</p>

  <p>The ODB compiler is a real C++ compiler except that it produces
     C++ instead of assembly or machine code. In particular, it is not
     an ad-hoc header pre-processor that is only capable of recognizing
     a subset of C++. ODB is capable of parsing any standard C++ code.</p>

  <p>The common runtime library defines database system-independant
     interfaces that your application can use to manipulate persistent
     objects. The database-specific runtime library provides implementations
     of these interfaces for a concrete database as well as other
     database-specific utilities that are used by the generated code.
     Normally, the application does not use the database-specific
     runtime library directly but rather works with it via the common
     interfaces from <code>libodb</code>. The following diagram shows
     the object persistence architecture of an application that uses
     MySQL as the underlying database system:</p>

  <p>@@ arch diagram</p>

  <p>The ODB system also defines two special-purpose languages:
     the ODB Pragma Language and ODB Query Language. The ODB Pragma
     Language is used to comminicate various properties of persistent
     classes to the ODB compiler by means of special <code>#pragma</code>
     directives embedded in the C++ header files. It controls such aspects
     of the object-relational mapping as names of tables and columns that
     are used for persistent classes and their members or mapping between
     C++ types and database types.</p>

  <p>The ODB Query Language is an object-oriented database query
     language that can be used to search for objects matching
     a certain criteria. It is modeled after and is integrated into
     C++ allowing you to write expressive and safe queries that look
     and feel like ordinary C++.</p>

  <p>The use of the ODB compiler to generate database support code
     adds an additional step to your application build sequence. The
     following diagram shows the typical build workflow of an application
     that uses ODB:</p>

  <p>@@ flow diagram</p>

  <h2><a name="1.2">1.2 Benefits</a></h2>

  <p>The traditional way of saving C++ objects to relational databases
     involves manually writen code that converts between the database
     and C++ representations of each persistent class. The actions that
     such code usually performs include conversion between C++ values and
     strings or database types, preparation and execution of SQL queries,
     and result set handling. Writing this code manually has the following
     drawbacks:</p>

  <ul class="list">
    <li><b>Difficult and time consuming.</b> Writing database conversion
        code for any non-trivial application requires extensive
        knowledge of the specific database system and its APIs.
        It can also take considereable amount of time to write
        and maintain. Supporting multi-threaded applications can
        complicate this task even further.</li>

    <li><b>Suboptimal performance.</b> Optimal conversion often
        requires writing large amouns of extra code, such as
        parameter binding for prepared statements and caching
        of connections, statements, and buffers. Writing such
        code in an ad-hoc manner is often too difficult and time
        consuming.</li>

    <li><b>Database vendor lock-in.</b> The conversion code is written for
        a specific database which makes it hard to switch to another
        database vendor.</li>

    <li><b>Lack of type safery.</b> It is easy to mispell column names or
        pass incomaptible values in SQL queries. Such errors will
        only be detected at query execution time.</li>

    <li><b>Complicates the application.</b> The database conversion code
        ends up interspersed throughout the application making it
        hard to debug, change, and maintain.</li>
  </ul>

  <p>In contrast, using ODB to implement C++ object persistence has the
     following benefits:</p>

  <ul class="list">
    <li><b>Ease of use.</b> ODB automatically generates database conversion
        code from your C++ class declarations and allows you to manipulate
        persistent objects using a simple, thread-safe, object-oriented
        database API.</li>

    <li><b>Concise code.</b> With ODB hiding the details of the underlying
        database, the application logic is wirtten using the natual object
        vocabulary instead of tables, columns and SQL. The resulting code
        is simpler and thus easier to read and understand.</li>

    <li><b>Optimal performance.</b> ODB has been designed for high performance
        and low memory overhead. All the available optimization techniques,
        such as prepared statements and extensive connection, statement,
        and buffer caching are used to provide the most efficient
        implementation for each database operation.</li>

    <li><b>Database portability.</b> Because the database conversion code
        is automatically generated, it is easy to switch from one database
        vendor to another. In fact, it is possible to test your application
        on several database systems before making a choice.</li>

    <li><b>Safety.</b> The ODB object persistence and query APIs are
        statically typed. You use C++ identifiers instead of strings
        to refer to object members and the generated code makes sure
        database and C++ types are compatible. All this helps catch
        programming errors at compile-time rather than at runtime.</li>

    <li><b>Maintainability.</b> Automatic code generation minimizes the
        effort needed to adapt the application to changes in persistent
        classes. The database support code is kept separately from the
        class declarations and application logic. This makes the
        application easier to debug and maintain.</li>
  </ul>

  <p>Overall, ODB provides an easy to use yet flexible and powerful
     object-relational mapping (ORM) system for C++. Unlike other
     ORM implementation for C++ that still require you to write
     database conversion or member registration code for each
     persistent class, ODB keeps persistent classes purely
     declarational. The functional part, the database conversion
     code, is automatically generated by the ODB compiler from
     these declarations.</p>


  <!-- CHAPTER -->


  <h1><a name="2">2 Hello World Example</a></h1>

  <p>In this chapter we will examine how to create a simple C++
     application that relies on ODB for object persistence using
     the traditional "Hello World" example. In particular, we will
     discuss how to declare persistent classes, generate database
     support code, as well as compile and run our application. We
     will also learn how to make objects persistent, load, update
     and delete persistent objects, as well as query the database
     for persistent objects that match a certain criteria.</p>

  <p>The code presented in this chapter is based on the
     <code>hello</code> example which can be found in the
     <code>odb-examples</code> package of the ODB distribution.</p>

  <h2><a name="2.1">2.1 Declaring a Persistent Class</a></h2>

  <p>In our "Hello World" example we will depart slighly from
     the norm and say hello to people instead of the world. People
     in our application will be represented as objects of C++ class
     <code>person</code> which is saved in <code>person.hxx</code>:</p>

  <pre class="c++">
// person.hxx
//

#include &lt;string>

class person
{
public:
  person (const std::string&amp; first,
          const std::string&amp; last,
          unsigned short age);

  const std::string&amp;
  first () const;

  const std::string&amp;
  last () const;

  unsigned short
  age () const;

  void
  age (unsigned short);

private:
  std::string first_;
  std::string last_;
  unsigned short age_;
};
  </pre>

  <p>In order not to miss anyone whom we need to greet, we would like
  to save the person objects in a database. To achive this we declare
  the <code>person</code> class as persistent:</p>

  <pre class="c++">
// person.hxx
//

#include &lt;string>

#include &lt;odb/code.hxx>     // (1)

#pragma db object           // (2)
class person
{
  ...

private:
  person () {}              // (3)

  friend class odb::access; // (4)

  #pragma db id auto        // (5)
  unsigned long id_;        // (5)

  std::string first_;
  std::string last_;
  unsigned short age_;
};
  </pre>

  <p>To be able to save person objects in the database we had to make
     five changes, marked with (1) to (5), to the orignal class
     definition. The first change is the inclusion of the ODB
     headers <code>&lt;odb/core.hxx></code>. This headers provides a number
     of core ODB declarations, such as <code>odb::access</code>, that
     are used to define peristent classes.</p>

  <p>The second change is the addition of <code>db object</code>
     pragma just before the class definition. This pragma tells the
     ODB compiler that the class that follows is persistent. Note
     that making a class persistent does not mean that all objects
     of this class will automatiacally be stored in the database.
     You would still create ordinary or <em>transient</em> instances
     of this class just as you would before. The difference is that
     now you can make such transient instances persistent, as we will
     see shortly.</p>

  <p>The third change is the addition of the default constructor.
     The ODB-generated database support code will use this constructor
     when instantiating an object from the persistent state. As we have
     done for the <code>person</code> class, you can make the default
     constructor private or protected if you don't want to make it
     available to the ordinary users of your class.</p>

  <p>With the fourth change we make the <code>odb::access</code> class
     friend of our <code>person</code> class. This is necessary to make
     the default constructor and the data members accessible to the
     ODB support code. If your class has public default constructor and
     public data members, then the <code>friend</code> declaration is
     unnecessary.</p>

  <p>The final change adds a data member called <code>id_</code> which
     is preceded by another pragma. In ODB every persistent object must
     have a unique, within its class, identifier. Or, in other words,
     no two persistent instances of the same type have equal
     identifiers. For our class we use an integer id. The
     <code>db id auto</code> pragma that preceeds the <code>id_</code>
     member tells the ODB compiler that the following member is the
     object's id. The <code>auto</code> specifier indicates that it is
     a database-assigned id. A unique id will be automatically generated
     by the database and assigned to the object when it is made
     persistent.</p>

  <p>In this example we choose to add an identifier because none of
     the existing members could serve the same purpose. However, if
     a class already has a member with suitable properties, then it
     is natural to use that member for an identifier. For example,
     if our <code>person</code> class contained some form of personal
     identification (SSN in the United States or ID/passport number
     in other countries), then we could use that as an id. Or, if
     we stored an email associated with each person, then we could
     have used that since each person is presumed to have a unqiue
     email address:</p>

  <pre class="c++">
class person
{
  ...

  #pragma db id
  std::string email_;

  std::string first_;
  std::string last_;
  unsigned short age_;
};
  </pre>

  <p>Now that we have the header file with the persistent class, let's
     see how to generate that database support code that we talked
     about.</p>

  <h2><a name="2.2">2.2 Generating Database Support Code</a></h2>

  <p>The persistent class definition that we created in the previous
     section was particularly light on code that could actualy
     do the job and store the person't data to a database. There
     was no serialization or deserialization code, not even data member
     registration, that you would normally have to write by hand in
     other ORM libraries for C++. This is because in ODB code
     that translates between the database and C++ representations
     of an object is automatically generated by the ODB compiler.</p>

  <p>To compile the <code>person.hxx</code> header we created in the
     previous section and generate the support code for the MySQL
     database we invoke the ODB compiler from a terminal (UNIX) or
     a command prompt (Windows):</p>

  <pre class="terminal">
odb -d mysql --generate-query person.hxx
  </pre>

  <p>We will use MySQL in the reminder of this chapter though other
     supported database systems can be used instead.</p>

  <p>If you haven't installed the common ODB runtime library
     (<code>libodb</code>) or installed it into a directory where
     the C++ compiler doesn't search for headers by default,
     then you may get the following error:</p>

  <pre class="terminal">
person.hxx:10:24: fatal error: odb/core.hxx: No such file or directory
  </pre>

  <p>To resolve this you will need to specify <code>libodb</code> headers
     location with the <code>-I</code> preprocessor option, for example:</p>

  <pre class="terminal">
odb -I.../libodb -d mysql --generate-query person.hxx
  </pre>

  <p>Here <code>.../libodb</code> represents the path to the
     <code>libodb</code> directory.</p>

  <p>The above invocation of the ODB compiler produces three C++ files:
     <code>person-odb.hxx</code>, <code>person-odb.ixx</code>,
     <code>person-odb.cxx</code>. You normally don't use types
     or functions contained in these files directly. Rather, all
     you have to do is include <code>person-odb.hxx</code> in
     C++ files where you are performing database operations
     with classes from <code>person.hxx</code> as well as compile
     <code>person-odb.cxx</code> and link the resulting object
     file to your application.</p>

  <p>You may be wondering what is the <code>--generate-query</code>
     option for. It instructs the ODB compiler to generate
     optional query support code that we will use later in our
     "Hello World" example. Another option that we will find
     useful is <code>--generate-schema</code>. This option
     makes the ODB compiler generate a fourth file,
     <code>person.sql</code>, which contains the database
     schema for the classes defined in <code>person.hxx</code>:</p>

  <pre class="terminal">
odb -d mysql --generate-query --generate-schema person.hxx
  </pre>


  <p>If you would like to see the list of all the available options,
     refer to the <a href="http://www.codesynthesis.com/products/odb/doc/odb.xhtml">ODB
     Compiler Command Line Manual</a>.</p>


  <p>Now that we have the persistent class and the database support
     code, the only part that is left is the application code that
     does something useful with all this. But before we move on to
     the fun part, let first learn how to build and run an application
     that uses ODB. This way when we have some application code
     to try, there are no more delays before we can run it.</p>

  <h2><a name="2.3">2.3 Compiling and Running</a></h2>

  <p>Assuming that the <code>main()</code> function with some application
     code is saved in <code>driver.cxx</code> and the database support
     code and schema are generated as described in the previous section,
     to build our application we will first need to compile all the C++
     source files and then link them with two ODB runtime libraries.</p>

  <p>On UNIX, the compilation part can be done with the following commands
     (for Microsoft Visual Studio setup, see the <code>odb-examples</code>
     package):</p>

  <pre class="terminal">
c++ -c driver.cxx
c++ -c person-odb.cxx
  </pre>

  <p>Similar to the ODB compilation, if you get an error stating that
  a headers in <code>odb/</code> or <code>odb/mysql</code> directory
  in not found. In this case you will need to use the <code>-I</code>
  preprocessor option to specify the location of the common ODB runtime
  library (<code>libodb</code>) and MySQL ODB runtime library
  (<code>libodb-mysql</code>).</p>

  <p>Once the compilation is done, we can link the application with
  the following command:</p>

  <pre class="terminal">
c++ -o driver driver.o person-odb.o -lodb-mysql -lodb
  </pre>

  <p>Notice that we link our application with two ODB libraries:
    <code>libodb</code> which is a common runtime library and
    <code>libodb-mysql</code> which is a MySQL runtime library
    (if you use another database, then the name of this library
    will change accordingly). If you get an error saying that
    one of these libraries could not be found, then you will need
    to use the <code>-L</code> linker option to specify their locations.</p>

  <p>Before we can run our application we need to create a database
    schema using the generated <code>person.sql</code> file. For MySQL
    we can use the <code>mysql</code> client program, for example:</p>

  <pre class="terminal">
mysql --user=odb_test --database=odb_test &lt; person.sql
  </pre>

  <p>The above command will login to a local MySQL server as user
    <code>odb_test</code> without a password and use database
    named <code>odb_test</code>. Note that after executing this
    command all data stored in the <code>odb_test</code> database
    will be deleted.</p>

  <p>Once the database schema is ready, we run our application
  using the same login and database name:</p>

  <pre class="terminal">
./driver --user odb_test --database odb_test
  </pre>


  <h2><a name="2.4">2.4 Making Objects Persistent</a></h2>

  <p>Now that we have the infrastructure work out of the way, it
  is time to see our first code fragment that interracts with the
  database. In this section we will learn how to make <code>person</code>
  objects persistent:</p>

  <pre class="c++">
// driver.cxx
//

#include &lt;memory>   // std::auto_ptr
#include &lt;iostream>

#include &lt;odb/database.hxx>
#include &lt;odb/transaction.hxx>

#include &lt;odb/mysql/database.hxx>

#include "person.hxx"
#include "person-odb.hxx"

using namespace std;
using namespace odb;

int
main (int argc, char* argv[])
{
  try
  {
    auto_ptr&lt;database> db (new mysql::database (argc, argv));

    unsigned long john_id, jane_id, joe_id;

    // Create a few persistent person objects.
    //
    {
      person john ("John", "Doe", 33);
      person jane ("Jane", "Doe", 32);
      person joe ("Joe", "Dirt", 30);

      transaction t (db->begin_transaction ());

      db->persist (john);
      db->persist (jane);
      db->persist (joe);

      t.commit ();

      // Save object ids for later use.
      //
      john_id = john.id ();
      jane_id = jane.id ();
      joe_id = joe.id ();
    }
  }
  catch (const odb::exception&amp; e)
  {
    cerr &lt;&lt; e.what () &lt;&lt; endl;
    return 1;
  }
}
  </pre>

  <p>Let's examine this code piece by piece. At the beginnig we include
     a bunch of headers. Those include <code>&lt;odb/database.hxx></code>
     and <code>&lt;odb/transaction.hxx></code> which define database
     system-independant <code>odb::database</code> and
     <code>odb::transaction</code> interfaces. Then we include
     <code>&lt;odb/mysql/database.hxx></code> which defines the
     MySQL implementation of the <code>database</code> interface. Finaly,
     we include <code>person.hxx</code> and <code>person-odb.hxx</code>
     which define our persistent <code>person</code> class.</p>

  <p>Once we are in <code>main()</code>, the first thing we do is create
     the MySQL database object. Notice that this is the last line in
     <code>driver.cxx</code> that mentions MySQL explicitly; the rest
     of the code works though the common interfaces and is database
     system-independant. We use the <code>argc</code>/<code>argv</code>
     <code>mysql::database</code> constructor which automatically
     extract the database parameters, such as login name, passowrd,
     database name, etc., from the command line. In your own applications
     you may prefer to use other variants of the <code>mysql::database</code>
     constructor which allow you to pass this information directly
     (@@ ref MySQL database).</p>

  <p>Next we create three <code>person</code> objects. Right now they are
     transient objects, which means that if we terminate the application
     at this point, they will be gone without any evidence of them ever
     existed. The next line starts a database transaction. We discuss
     transactions in detail later in this manual. For now all we need
     to know is that all ODB database operations must be performed within
     a transaction and that a transaction is an atomic unit of work; all
     database operations performed within a transaction either succeed
     (commited) together or are automatically undone (rolled back).</p>

  <p>Once we are in a transaction, we call the <code>persist()</code>
     database function on each of our <code>person</code> objects.
     At this point the state of each object is saved in the database.
     However, note that this state is not permanent until and unless
     the transaction is commited. If, for example, our application
     crashes at this point, there will still be no evidence of our
     objects ever existed.</p>

  <p>In our case one more thing happens when we call <code>persist()</code>
     on a <code>person</code> object. Remember that we decided to use
     database-assigned identifiers for our objects. The call to
     <code>persist()</code> is where this assignment happens. Once
     this function returns, the <code>id_</code> member contains this
     object's unique identifier.</p>

  <p>After we have persisted our objects, it is time to commit the
     transaction and make the changes permanent. Only after the
     <code>commit()</code> function returns succefully are we
     guaranteed that the objects are made persistent. Following
     the crashing example, if our application terminates after
     the commit for whatever reason, the objects' state in the
     database will remain intact. In fact, as we will discover
     shortly, our application can be restarted and load the
     orignal objects from the database. Note also that a
     transaction must be commited explicitly with the
     <code>commit()</code> call. If the <code>transaction</code>
     object leaves scope without the transaction beeing
     explicitly commited or rolled back, it will be automatically
     rolled back. This behavior allows you not to worry about
     exceptions being thrown within a transaction; if they
     cross the transaction boundaries, the transaction will
     be automatically rolled back and all the changes made
     to the database undone.</p>

  <p>After the transaction has been commited, we save the persistent
     objects' ids in local variables. We will use them later in this
     chapter to perform other database operations on our persistent
     objects. You might have noticed that our <code>person</code>
     class doesn't have the <code>id()</code> function that we use
     here. To make our code work we need to add a simple accessor
     with this name that returns the value of the <code>id_</code>
     data member.</p>

  <p>The final bit of code in our example is the <code>catch</code>
     block that handles the ODB exceptions. We do this by catching
     the base ODB exception and printing the diagnostics. (@@ Ref
     exceptions)</p>

  <p>Let's now compile (see @@ Ref "Compiling and Running") and then
     run our first ODB application:</p>

  <pre class="terminal">
mysql --user=odb_test --database=odb_test &lt; person.sql
./driver --user odb_test --database odb_test
  </pre>

  <p>Our first application doesn't print anything except for error
     messages so we can't really tell whether it actually stored the
     objects' state in the database. While we will extend our application
     to be more enternaining, for now we can use the <code>mysql</code>
     client to examine the database content. It will also give us a feel
     for how the object are stored:</p>

  <pre class="terminal">
mysql --user=odb_test --database=odb_test

Welcome to the MySQL monitor.

mysql> select * from person;

+----+-------+------+-----+
| id | first | last | age |
+----+-------+------+-----+
|  1 | John  | Doe  |  33 |
|  2 | Jane  | Doe  |  32 |
|  3 | Joe   | Dirt |  30 |
+----+-------+------+-----+
3 rows in set (0.00 sec)

mysql> quit
  </pre>

  <p>In the next section we will examine how to query the database
     for persistent objects matching a certain criteria.</p>

  <h2><a name="2.4">2.4 Querying Database for Objects</a></h2>

  <p>So far our application doesn't resemble a typical "Hello World"
     example. It doesn't print anything except for error messages.
     Let's change that and teach our application to say hello to
     people from our database. To make it a bit more interesting,
     let's say hello only to people over 30:</p>

  <pre class="c++">
// driver.cxx
//

...

int
main (int argc, char* argv[])
{
  try
  {
    ...

    // Create a few persistent person objects.
    //
    {
      ...
    }

    typedef odb::query&lt;person> query;
    typedef odb::result&lt;person> result;

    // Say hello to those over 30.
    //
    {
      transaction t (db->begin_transaction ());

      result r (db->query&lt;person> (query::age > 30));

      for (result::iterator i (r.begin ()); i != r.end (); ++i)
      {
        cout &lt;&lt; "Hello, " &lt;&lt; i->first () &lt;&lt; "!" &lt;&lt; endl;
      }

      t.commit ();
    }
  }
  catch (const odb::exception&amp; e)
  {
    cerr &lt;&lt; e.what () &lt;&lt; endl;
    return 1;
  }
}
  </pre>

  <p>The first half of our application is the same as before and is
     replaced with "..." in the above listing for brievety. Again, let's
     examine the rest of it piece by piece.</p>

  <p>The two <code>typedef</code>s create convenient aliases for two
     template instantiations that will be used a lot in our application.
     The first is the query type for the <code>person</code> objects
     and the second is the result type of that query.</p>

  <p>Then we begin a new transaction and call the <code>query()</code>
     database function. We pass a query expression
     (<code>query::age > 30</code>) which limits the returned objects
     only to those with age greater than 30. We also save the result
     of the query in a local variable.</p>

  <p>The next few lines perform a pretty standard for-loop iteration
     over the result sequence printing hello for every returned person.
     Then we commit the transaction and we are node. Let's see what
     this application will print:</p>

  <pre class="terminal">
mysql --user=odb_test --database=odb_test &lt; person.sql
./driver --user odb_test --database odb_test

Hello, John!
Hello, Jane!
  </pre>


  <p>That looks about right but how do we know that the query actually
     used the database instead of just using some in-memory artifacts of
     the earlier <code>persist()</code> calls. One way to test this
     would be to comment out the first transaction in our application
     and re-run it without re-creating the database schema so that the
     objects that were persisted during the previous run will be returned.
     Alternatively, we can just re-run the same application without
     re-creating the schema and notice that we now how duplicate
     objects:</p>

  <pre class="terminal">
./driver --user odb_test --database odb_test

Hello, John!
Hello, Jane!
Hello, John!
Hello, Jane!
  </pre>

  <p>What happens here is that the previous run of our application
     persisted a set of <code>person</code> objects and when we re-run
     the application, we persist another set with the same names but
     with different id. When we later run the query, matches from
     both sets are returned. We can change the line where we print
     the "Hello" string as follows to illustrate this point:</p>

  <pre class="c++">
cout &lt;&lt; "Hello, " &lt;&lt; i->first () &lt;&lt; " (" &lt;&lt; i->id () &lt;&lt; ")!" &lt;&lt; endl;
  </pre>

  <p>If we now re-run this modified program, we will get the following
     output:</p>

  <pre class="terminal">
./driver --user odb_test --database odb_test

Hello, John (1)!
Hello, Jane (2)!
Hello, John (4)!
Hello, Jane (5)!
Hello, John (7)!
Hello, Jane (8)!
  </pre>

  <p>The identifiers 3, 6, and 9 that miss from the above list belong to
     the "Joe Dirt" objects which are not selected by this query.</p>

  <h2><a name="2.5">2.5 Updating Persistent Objects</a></h2>

  <p>While making objects persistent and then selecting some of them using
     queries ara two useful operations, most applications will also need
     to change the object's state and then make these changes persistent.
     Let's illustrate this by updating Joe's age who just had a birthday:</p>

  <pre class="c++">
// driver.cxx
//

...

int
main (int argc, char* argv[])
{
  try
  {
    ...

    unsigned long john_id, jane_id, joe_id;

    // Create a few persistent person objects.
    //
    {
      ...

      // Save object ids for later use.
      //
      john_id = john.id ();
      jane_id = jane.id ();
      joe_id = joe.id ();
    }

    // Joe Dirt just had a birthday, so update his age.
    //
    {
      transaction t (db->begin_transaction ());

      auto_ptr&lt;person> joe (db->load&lt;person> (joe_id));
      joe->age (joe->age () + 1);
      db->store (*joe);

      t.commit ();
    }

    // Say hello to those over 30.
    //
    {
      ...
    }
  }
  catch (const odb::exception&amp; e)
  {
    cerr &lt;&lt; e.what () &lt;&lt; endl;
    return 1;
  }
}
  </pre>

  <p>The beginning and the end of this transaction are the same as
     the previous two. Once within a transaction, we call the
     <code>load()</code> database function to instantiate a
     <code>person</code> object with Joe's persistent state. We
     pass Joe's object identifer that we stored earlier when we
     made this object persistent.</p>

  <p>With the instantiated object in hand we increment the age
     and call the <code>store()</code> database function to update
     the object's state in the database. Once the transaction is
     commited, the changes are made permanent in the database.</p>

  <p>If we now run this application, we will see Joe in the output
     since he is now over 30:</p>

  <pre class="terminal">
mysql --user=odb_test --database=odb_test &lt; person.sql
./driver --user odb_test --database odb_test

Hello, John!
Hello, Jane!
Hello, Joe!
  </pre>

  <p>What if we didn't have an identifier for Joe? Maybe this object
     was made persisted in another run of our application or by another
     application altogether. Provided that we have only one Joe Dirt
     in the database, we can use the query facility to come up with
     an alternative implementation of the above transaction:</p>

  <pre class="c++">
    // Joe Dirt just had a birthday, so update his age. An
    // alternative implementation without using the object id.
    //
    {
      transaction t (db->begin_transaction ());

      result r (db->query&lt;person> (query::first == "Joe" &amp;&amp;
                                   query::last == "Dirt"));

      result::iterator i (r.begin ());

      if (i != r.end ())
      {
        auto_ptr&lt;person> joe (*i);
        joe->age (joe->age () + 1);
        db->store (*joe);
      }

      t.commit ();
    }
  </pre>

  <h2><a name="2.5">2.5 Deleting Persistent Objects</a></h2>

  <p>The last operation that we will discuss in this chapter is deleting
     the persistent object from the database. The following code
     fragment shows how we can delete an object given its identifier:</p>

  <pre class="c++">
    // John Doe is no longer in our database.
    //
    {
      transaction t (db->begin_transaction ());
      db->erase&lt;person> (john_id);
      t.commit ();
    }
  </pre>

  <p>To delete John from the database we start a transaction, call
     the <code>erase()</code> database function with John's object
     id, and commit the transaction. After the transaction is commited
     the erased object is no longer persistent.</p>

  <p>If we don't have an object id handy, we can use queries to find
     and delete the object:</p>

  <pre class="c++">
    // John Doe is no longer in our database. An alternative
    // implementation without using the object id.
    //
    {
      transaction t (db->begin_transaction ());

      result r (db->query&lt;person> (query::first == "John" &amp;&amp;
                                   query::last == "Doe"));

      result::iterator i (r.begin ());

      if (i != r.end ())
      {
        auto_ptr&lt;person> john (*i);
        db->erase (*john);
      }

      t.commit ();
    }
  </pre>

  <h2><a name="2.5">2.5 Summary</a></h2>

  <p>This chapter presented a very simple application which, nevertheless,
     excercised all core database functions: <code>persist()</code>,
     <code>query()</code>, <code>load()</code>, <code>store()</code>,
     and <code>erase()</code>. We also saw that writing an application
     that uses ODB involves the following steps:</p>

  <ol>
    <li>Declare persistent classes in header files.</li>
    <li>Compile these headers to generate database support code.</li>
    <li>Link the application with the support code and two ODB runtime libraries.</li>
  </ol>



  <p>Do not be concerned if, at this point, much appears unclear. The intent
     of this chapter is to give you only a general idea of how to persist C++
     objects with ODB. We will cover all the details throughout the remainder
     of this manual.</p>


  <!-- CHAPTER -->


  <h1><a name="3">3 Working with Persistent Objects</a></h1>

  <p>@@</p>

  <p>In this chapter we will continue to use and exapand the
     <code>person</code> persistent class that we have developed in the
     previous chapter.</p>

  <h2><a name="3.1">3.1 Base Concepts</a></h2>

  <p>The term <em>database</em> can refer to three distinct things:
     a general notion of a place where an application stores its data,
     a software implementation for managing this data (for example
     MySQL), and, finally, some database software implementations
     may manage several data stores which are usually distinguished
     by name. This name is also commonly referred to as database.</p>

  <p>In this manual, when we use just the word <em>database</em>, we
     refer to the first meaning above, for example,
     "The <code>store()</code> function saves the object's state to
     the database." The term Database Management System (DBMS) is
     often used to refer to the second meaning of the words database.
     In this manual we will use the term <em>database system</em>
     for short, for example, "Database system-independant
     application code." Finally, to distinguish the third meaning
     from the other two we will use the term <em>database name</em>,
     for example, "The second option specfies the database name
     that the application should use to store its data."</p>

  <p>In C++ there is only one notion of a type and an instance
     of a type. For example, a fundamental type, such as <code>int</code>,
     is, for the most part, treated the same as a user defined class
     type. However, when it comes to persistence, we have to place
     certain restrictions and requirements on certain C++ types that
     can be stored in the database. As a result, we devide persistent
     C++ types into two groups: <em>object types</em> and <em>value
     types</em>. An stances of an object type is called an <em>object</em>
     and an instance of a value type &mdash; a <em>value</em>.</p>

  <p>An object is an independant entity. It can be stored, updated,
     and deleted in the database independant of other objects or values.
     An object has an identifier, called <em>object id</em>, that is
     unique among all instances of an object type within a database.
     An object consits of data members which are either values or
     references to other objects. In contrast, a value can only be
     stored in the database as part of an object and doesn't have
     its own unique identifier.</p>

  <p>An object type is a C++ class. Because of this one to one
     relationship, we will use terms <em>object type</em>
     and <em>object class</em> interchangably. In contrast,
     a value type can be a fundamental C++ type, such as
     <code>int</code> or a class type, such as <code>std::string</code>.
     If a value consists of other values then is is called a
     <em>composite value</em> and its type &mdash; a
     <em>composite value type</em>. Otherwise the the value is
     called <em>simple value</em> and its type &mdash; a
     <em>simple value type</em>. Note that the distinction between
     simple and composite values is conceptual rather than
     representational. For example, <code>std::string</code>
     is a simple value type because conceptually string is a
     single value even though the representation of the string
     class may contain several data member each of which would be
     considered a value. In fact, the same value type can be
     viewed (and mapped) as both simple and composite by different
     applications.</p>

  <p>Seeing how all these concepts map to the relational model
     will hopefully make these distinctions more clear. In a relational
     database an object type is mapped to a table and a value type is
     mapped to one or more columns. A simple value type is mapped
     to a single column while a composite value type is mapped to
     several columns. Conversly, an object is stored as a row in this
     table and a value is stored as one or more cells in this row.
     A simple value is stored in a single cell while a composite
     value occupies several cells.</p>

  <p>Going back to the distinction beetween simple and composite
     values, consider a date type which has three integer data
     members: year, month, and day. In one application it can be
     conidered a composite value and each member will get its
     own column in the relational database. In another application
     it can considered as a simple value and stored a single
     column as a number of day from some predefined date.</p>

  <p>Until now, we have been using the term <em>persistent class</em>
     to refer to object classes. We will continue to do so even though
     a value type can also be a class. The reason for this assimetry
     is the subordinate nature of value types when it comes to
     database operations. Remember that values are never stored
     directly but rather as part of an object that contains them.
     As a result, when we say that we want to make a C++ class
     persistent or persist an instance of a class in the database,
     we invariably refer to an object class rather than a value
     class.</p>

  <p>To make a C++ class a persistent object class we need to declare
     it as such using the <code>db object</code> pragma:</p>

  <pre class="c++">
    #pragma db object
    class person
    {
      ...
    };
  </pre>

  <p>The other pargma that we need to use is the <code>db id</code>
     which designates one of the data members as an object id:</p>

  <pre class="c++">
    #pragma db object
    class person
    {

    private:
      #pragma db id
      unsigned long id_;
    };
  </pre>

  <p>These two pragmas are the minimum required to declare a
     persistent class. Other pragmas can be used to fine-tune
     the persistence-related properties of a class and its
     members.</p>

  <p>You may be wondering whether we aslo have to do declare value types
     as persistent. We don't need to do anything special for simple value
     types such as <code>int</code> or <code>std::string</code> since the
     ODB compiler knows how to map them to the database system types and
     how to convert between the two. On the other hand, if a simple value
     is unknown to the ODB compiler then you will need to provide the
     mapping to the database system type and, possibly, the code to
     convert between the two. For more information on this see @@ Ref
     Custom value types/pragma value type. Composite value types are
     not yet supported by ODB and will not discuss them further in
     this revision of the manual.</p>

  <p>Normally, you would use object types to model real-world entities,
     things that have their own identity. For example, in the
     previous chapter we created a <code>person</code> class to model
     a person which is a real-world enitity. Name and age, which we
     used as data members in our <code>person</code> class are clearly
     values. It is hard to think of age 31 or name "Joe" as having their
     own identity.</p>

  <p>A good test to determine whether something is an object or
     a value is to consider if other objects might reference
     it. A person is clearly an object because it can be refered
     to by other object's such as a spouce, an employer, or a
     bank. On the other hand, a person's age or name is not
     something that other objects would normally refer to.</p>

  <p>Also, when an object represents a real entity, it is easy to
     choose a suitable object identifier. For example, for a
     person there is an established notion of an identifier
     (SSN, student id, passport number, etc). Another alternative
     is to use person't email address as an identifier.</p>

  <p>Note, however, that these are only guidelines. There could
     be goot reasons to make something that would normally be
     a value an object. Consider, for example, a database that
     stores a vast number of people. Many of the person objects
     in this database have the same names and surnames and the
     overhead of repeating them in every object may negatively
     affect the performance. In this case we could make first name
     and last name each an object and only store references to
     these objects in the <code>person</code> class.</p>

  <p>An instance of a persistent class can be in one of two states:
    <em>transient</em> and <em>persistent</em>. A transient
    instance only has a representation in the applciation's
    memory and will ceas to exist when the application terminates
    unless it is explicitly made persistent. A persistent instance
    has a representation in both the application's memory and the
    database. A persistent instance will remain even after the
    application terminates unless and until it is explicitly
    deleted from the database. In other words, a transient instance
    of a persistent class behaves just like an instance of any
    ordinary C++ class.</p>


  <h2><a name="3.2">3.2 Database</a></h2>

  <p>Before an application can make use of a persistence services
     offered by ODB, it has to create a database instance. A
     database instance is the representation of the place where
     the application stores its persistent objects. You create
     a database instance by instantiating one of the database
     system-specific classes. For example <code>odb::mysql::database</code>
     would be such a class for the MySQL database system. You will
     also normally pass a database name as an argument to the
     <code>database</code> class' constructor. The following
     code fragment shows how we can create a database instance
     for the MySQL database system:</p>

  <pre class="c++">
  #include &lt;odb/database.hxx>
  #include &lt;odb/mysql/database.hxx>

  auto_ptr&lt;odb::database> db (
    new odb::mysql::database (
      "test_user"     // database login name
      "test_password" // database password
      "test_database" // database name
      ));
  </pre>

  <p>The <code>odb::database</code> class is an abstract base class
     that defines a common interface for all database system-specific
     classes provided by ODB. You would normally work with the database
     instance via this interface unless there is a specific
     functionality that your application depends on and which is
     only exposed by a particular system's <code>database</code>
     class. You will need to include the <code>&lt;odb/database.hxx></code>
     header file to make this class available in your application.</p>

  <p>The <code>odb::database</code> interface defines functions for
     starting transactions and manipulating persistent objects.
     These are discussed in detail in the reminder of this chapter
     as well as the next chapter which is dedicated to the topic of
     querying the database for persistent objects. For details on the
     system-specific <code>database</code> classes, refer for
     (@@ ref Database Systems).</p>

  <h2><a name="3.3">3.3 Transactions</a></h2>

  <p>A transaction is an atomic, consistent, isolated and durable
     (ACID) unit of work. All database operations can only be
     performed within a transaction and each thread of execution
     in an application can have only one active transaction at a
     time.</p>

  <p>By atomicity we mean that when it comes to making changes to
     the database state within a transaction,
     either all the changes succeed or none at all. Consider,
     for example, a transaction that transfers funds between two
     objects representing bank accounts. If the debit function
     on the first object succeeds but the credit function on
     the second fails, the transaction is rolled back and the
     database state of the first object remains unchanged.</p>

  <p>By consistency we mean that a transaction must take all the
     objects stored in the database from one consistent state
     to another. For example, if a bank account object must
     reference a person object as its owner and we forget to
     set this reference before making the object persistent,
     the transaction will be rolled back and the database
     will remain unchanged.</p>

  <p>By isolation we mean that the changes made to the database
     state during a transaction are only visible inside this
     transaction until and unless it is commited. Using the
     above example with bank transfer, the results of the
     debit operation performed on the first object is not
     visible to other transactions until the credit operation
     is successfully completed and the transaction is commited.</p>

  <p>By durability we mean that once the transaction is committed,
     the changes that it made to the database state are permanent
     and will survive failures such as an application crash. From
     now the only way to alter this state is to execute and commit
     another transaction.</p>

  <p>A transaction is started by calling the
     <code>database::begin_transaction()</code>
     function. The returned transaction handle is stored in
     an instance of the <code>odb::transaction</code> class.
     You will need to include the <code>&lt;odb/transaction.hxx></code>
     header file to make this class available in your application.
     The <code>odb::transaction</code> class has the following
     interface:</p>

  <pre class="c++">
namespace odb
{
  class transaction
  {
  public:
    typedef odb::database database_type;

    void
    commit ();

    void
    rollback ();

    database_type&amp;
    database ();

    static transaction&amp;
    current ();

    static bool
    has_current ();
  };
}
  </pre>

  <p>The <code>commit()</code> function commits a transaction and
     <code>rollback()</code> rolls it back. Unless the transaction
     has been <em>finalized</em>, (explicitly commited or rolled back),
     the destructor of the <code>odb::transaction</code> class will
     automatically roll it back when the transaction instance goes
     out of scope. If you try to commit or roll back a finalized
     transactions, the <code>odb::transaction_already_finilized</code>
     is thrown.</p>

  <p>The <code>database()</code> function returns the database this
     transaction is working on. The <code>current()</code> static
     function returns the currently active transaction for this
     thread. If there is no active transaction, this function
     throws the <code>odb::not_in_transaction</code> exception.
     You can check whether there is a transaction in effect using
     the <code>has_current()</code> static function.</p>

  <p>If two or more transaction access or modify more than one object
     and are executed concurrently by different applications or by
     different threads within the same application, then it is possible
     that these transactions will try to access objects in an incompatible
     order and deadlock. The canonical example of a deadlock are
     two transactions in which the first has modified <code>object1</code>
     and is waiting for the second transaction to commit its changes to
     <code>object2</code> so that it can update <code>object2</code>. At
     the same time the second transaction has modified <code>object2</code>
     and is waiting for the first transaction to commit its changes to
     <code>object1</code> because it also needs to modify <code>object1</code>.
     As a result none of the two transactions can complete.</p>

  <p>The database system detects such situations and automatically
     aborts the waiting operation in one of the deadlocked transactions.
     In ODB this translates to the <code>odb::deadlock</code> exception
     being thrown from one of the database functions. You would normally
     handle a deadlock by restarting the transaction, for example:</p>

  <pre class="c++">
for (;;)
{
  try
  {
    transaction t (db.begin_transaction ());

    ...

    t.commit ();
    break;
  }
  catch (const odb::deadlock&amp;)
  {
    continue;
  }
}
  </pre>

  <p>Note that in the above discussion of atomicity, consistency,
     isolation, and durability, all of these guarantees only apply
     to the object's state in the database as opposed to the object's
     state in the application's memory. It is possible to roll
     a transaction back but still have changes from this
     transaction in the application's memory. An easy way to
     avoid this potentiall inconsistency is to instantiate
     persistent objects withing the transaction's scope. Consider,
     for example, this two implementations of the same transaction:</p>

  <pre class="c++">
void
update_age (database&amp; db, person&amp; p)
{
  transaction t (db.begin_transaction ());

  p.age (p.age () + 1);
  db.store (p);

  t.commit ();
}
  </pre>

  <p>In the above implementation, if the <code>store()</code> call fails
     and the transaction is rolled back, the state of the person
     object in the database and the state of the same object in the
     application's memory will differ. Now consider an
     alternative implementation which only instantiates the
     person object for the duration of the transaction:</p>

  <pre class="c++">
void
update_age (database&amp; db, unsigned long id)
{
  transaction t (db.begin_transaction ());

  auto_ptr&lt;person> p (db.load&lt;person> (id));
  p.age (p.age () + 1);
  db.store (p);

  t.commit ();
}
  </pre>

  <p>Of course, it may be not always be possible to write the
     application in this style. Oftentimes we need to access and
     modify application's state of persistent objects out of
     transactions. In this case it may make sense to try to
     roll back the changes made to the application state if
     the transaction was rolled back and the database state
     remains unchanged. One way to do this is to re-load
     the object's state from the database:</p>

  <pre class="c++">
void
update_age (database&amp; db, person&amp; p)
{
  try
  {
    transaction t (db.begin_transaction ());

    p.age (p.age () + 1);
    db.store (p);

    t.commit ();
  }
  catch (...)
  {
    transaction t (db.begin_transaction ());
    db.load (p.id (), p);
    t.commit ();

    throw;
  }
}
  </pre>


  <h2><a name="3.4">3.4 Making Objects Persistent</a></h2>

  <p>A newly created instance of a persistent class is transient.
     We use the <code>database::persist()</code> function template
     to make a transient instance persistent. This function has two
     overloaded variants with the following signatures:</p>

  <pre class="c++">
  template &lt;typename T>
  typename object_traits&lt;T>::id_type
  persist (const T&amp; object);

  template &lt;typename T>
  typename object_traits&lt;T>::id_type
  persist (T&amp; object);
  </pre>

  <p>The first <code>persist()</code> variant expects a constant reference
     to an instance being persisted and is used on objects with
     application-assigned object ids (@@ref pragma id/auto). The second
     variant expects an unrestricted reference and, if the object id is
     assigned by the database, it updates the passed instance's id member
     with the assigned value. Both variants return the object id of the
     newly persistent object.</p>

  <p>If the database already contains an object of this type with this
     id, the <code>persist()</code> functions throw the
     <code>odb::object_already_persistent</code> exception. This should
     never happen for database-assigned object ids as long as the
     number of objects persisted does not exceed the value space of
     the id type.</p>

  <p>When calling the <code>persist()</code> function we don't need to
     explicitly specify the template type since it will be automatically
     deduced from the argument being passed. The <code>odb::object_traits</code>
     template used in the signature above is part of the database support
     code generated by the ODB compiler.</p>

  <p>The following example shows how we can call this function:</p>

<pre class="c++">
person john ("John", "Doe", 33);
person jane ("Jane", "Doe", 32);

transaction t (db->begin_transaction ());

db->persis (john);
unsigned long jane_id (db->persist (jane));

t.commit ();

cerr &lt;&lt; "Jane's id: " &lt;&lt; jane_id &lt;&lt; endl;
</pre>

  <p>Notice that in the above code fragment we have created instances
     that we were planning to make persistent before starting the
     transaction. Likewise, we printed Jane's id after we have commited
     the transaction. As a general rule, you should avoid performing
     operations within a transaction's scope that can be performed
     before the transaction starts or after it terminates. An active
     transaction consumes both your application's resources, such as
     a database connection, as well as the database server's
     resources, such as object locks. By following the above rule you
     make sure these resources are made available to other threads
     in your application and to other applications for as long as
     possible.</p>

  <h2><a name="3.5">3.5 Loading Persistent Objects</a></h2>

  <p>Once an object is made persistent, and you know its object id, it
     can loaded by the application using the <code>database::load()</code>
     function template. This function has two overloaded variants with
     the following signatures:</p>

  <pre class="c++">
  template &lt;typename T>
  typename object_traits&lt;T>::pointer_type
  load (const typename object_traits&lt;T>::id_type&amp; id);

  template &lt;typename T>
  void
  load (const typename object_traits&lt;T>::id_type&amp; id, T&amp; object);
  </pre>

  <p>Given an object id, the first variant allocates a new instance
     of the object class in the dynamic memory, loads its state from
     the database, and returns the pointer to the new instance. The
     second variant loads the object's state into an existing instance.
     Both functions throw <code>odb::object_not_persistent</code> if
     there is no object of this type with this id in the database.</p>

  <p>When we call the first variant of <code>load()</code> we need to
     explicitly specify the object type. We don't need to do this for
     the second variant because the object type will be automatically
     deduced from the second argument, for example:</p>

  <pre class="c++">
transaction t (db->begin_transaction ());

person* jane (db->load&lt;person> (jane_id));

db->load (jane_id, *jane);

t.commit ();
  </pre>

  <p>If we don't know for sure whether an object with a gived id
     is persistent, we can use the <code>find()</code> function
     instead of <code>load()</code>:</p>

  <pre class="c++">
  template &lt;typename T>
  typename object_traits&lt;T>::pointer_type
  find (const typename object_traits&lt;T>::id_type&amp; id);

  template &lt;typename T>
  bool
  find (const typename object_traits&lt;T>::id_type&amp; id, T&amp; object);
  </pre>

  <p>If an object with this id is not found in the database, the first
     variant of <code>find()</code> returns a <code>NULL</code> pointer
     while the second variant leaves the passed instance unmodified and
     returns <code>false</code>.</p>

  <p>If we don't know an object's identifier, then we can use queries to
     find the object (or objects) matching some other criteria (@@ ref
     query). Note, however, that loading an object's state using its
     identifier can be significantly faster that doing a query.</p>


  <h2><a name="3.5">3.5 Updating Persistent Objects</a></h2>

  <p>If a persistent object has been modified, we can store the updated
     state in the database using the <code>database::update()</code>
     function template:</p>

  <pre class="c++">
  template &lt;typename T>
  void
  update (const T&amp; object);
  </pre>

  <p>If the object passed to this function does not exist in the
     database, <code>update()</code> throws the
     <code>odb::object_not_persistent</code> exception.</p>

  <p>Below is an example of the funds transfer that we talked about
     in the earlier section on transactions. It uses the hypothetical
     <code>bank_account</code> persistent class:</p>

  <pre class="c++">
void
transfer (database&amp; db,
          unsigned long from_acc,
          unsigned long to_acc,
          unsigned int amount)
{
  bank_account from, to;

  transaction t (db.begin_transaction ());

  db.load (from_acc, from);

  if (from.balance () &lt; amount)
    throw insufficient_funds ();

  db.load (to_acc, to);

  to.balance (to.balance () + amount);
  from.balance (from.balance () - amount);

  db.update (to);
  db.update (from);

  t.commit ();
}
  </pre>

  <h2><a name="3.6">3.6 Deleting Persistent Objects</a></h2>

  <p>To delete a persistent object's state from the database we use the
     <code>database::erase()</code> function template. If the application
     still has an instance of the erased object, this instance becomes
     transient. The <code>erase()</code> function has the following
     overloaded variants:</p>

  <pre class="c++">
  template &lt;typename T>
  void
  erase (const T&amp; object);

  template &lt;typename T>
  void
  erase (const typename object_traits&lt;T>::id_type&amp; id);
  </pre>

  <p>The first variant uses an object itself to delete its state from
     the database. The second variant uses the object id to identify
     the object to be deleted. If the object to be deleted does not
     exist in the database, both variants throw the
     <code>odb::object_not_persistent</code> exception.</p>


  <p>We have to specify the object type when calling the second variant
     of <code>erase()</code>. The same is unnecessary for the first
     variant because the object type will be automomatically deduced
     from its argument. The following example shows how can call
     this function:</p>

  <pre class="c++">
const person&amp; john = ...

transaction t (db->begin_transaction ());

db->erase (john);
db->erase&lt;person> (jane_id);

t.commit ();
  </pre>

  <h2><a name="3.7">3.7 ODB Exceptions</a></h2>

  <p>In the previous sections we have already mentioned some of the
     exceptions that can be thrown by the database functions. In this
     section we will discuss the ODB exception hierarchy and list
     all the exceptions that can be thrown by the common ODB
     runtime.</p>

  <p>The root of the ODB exception hierarchy is the abstract
     <code>odb::exception</code> class. This class inherits
     from <code>std::exception</code> and has the following
     interface:</p>

  <pre class="c++">
namespace odb
{
  struct exception: std::exception
  {
    virtual const char*
    what () const throw () = 0;
  };
}
  </pre>

  <p>Catching this exception guarantees that you will catch all
     exceptions thrown by ODB. The <code>what()</code> function
     returns a human-readable description of an exception.</p>

  <p>The concrete exceptions that can be thrown by ODB are presented
     in the following listing:</p>

  <pre class="c++">
namespace odb
{
  struct already_in_transaction: odb::exception
  {
    virtual const char*
    what () const throw ();
  };

  struct not_in_transaction: odb::exception
  {
    virtual const char*
    what () const throw ();
  };

  struct transaction_already_finilized: odb::exception
  {
    virtual const char*
    what () const throw ();
  };

  struct deadlock: odb::exception
  {
    virtual const char*
    what () const throw ();
  };

  struct object_not_persistent: odb::exception
  {
    virtual const char*
    what () const throw ();
  };

  struct object_already_persistent: odb::exception
  {
    virtual const char*
    what () const throw ();
  };

  struct database_exception: odb::exception
  {
  };
}
  </pre>

  <p>The first four exception (<code>already_in_transaction</code>,
     <code>not_in_transaction</code>,
     <code>transaction_already_finilized</code>, and
     <code>deadlock</code>) are thrown by the
     <code>odb::transaction</code> class and are discussed
     in <a href="#3.3">Section 3.3, "Transactions"</a>.</p>

  <p>The <code>object_already_persistent</code> exception is thrown
     by the <code>persist()</code> database function. See
     <a href="#3.4">Section 3.4, "Making Objects Persistent"</a>
     for details.</p>

  <p>The <code>object_not_persistent</code> exception is thrown
     by the <code>load()</code>  and <code>update()</code>
     database functions. Refer to
     <a href="#3.5">Section 3.5, "Loading Persistent Objects"</a> and
     <a href="#3.6">Section 3.6, "Updating Persistent Objects"</a> for
     more information.</p>

  <p>The <code>database_exception</code> is a base class for all
     database system-specific exceptions that are thrown by the
     database system-specific runtime library. See (@@ ref Chapter
     Database Systems) for more information.</p>

  <p>The <code>odb::exception</code> abstract base is defined in the
     <code>&lt;odb/exception.hxx></code> header file. All the
     concrete ODB exceptions are defined in
     <code>&lt;odb/exceptions.hxx></code> which also includes
     <code>&lt;odb/exception.hxx></code>. Normally you don't
     need to include either of these two headers because they are
     automatically included by <code>&lt;odb/database.hxx></code>.
     However, if the source file that handles ODB exceptions
     does not include <code>&lt;odb/database.hxx></code>, then
     you will need to explicitly include one of these headers.</p>


  <!-- CHAPTER -->


  <h1><a name="4">4 Querying the Database</a></h1>

  <p>If you don't know the identifiers of the objects that you are looking
     for, you can use queries to search the database for objects matching
     a certain criteria. ODB provides flexible and powerful query support
     that offers two distinct levels of abstraction from the database
     system query language such as SQL.</p>

  <p>At the high level you are presented with an easy to use yet powerful
     object oriented query language, called ODB query language. This
     query language is modeled after and is integrated into C++ allowing
     you to write expressive and safe queries that look and feel like
     ordinary C++. We have already seen examples of these queries in the
     introductory chapters. Below is another, more interesting, example:</p>

  <pre class="c++">
  typedef odb::query&lt;person> query;
  typedef odb::result&lt;person> result;

  unsigned short age;
  query q (query::first == "John" &amp;&amp; query::age &lt; query::_ref (age));

  for (age = 10; age &lt; 100; age += 10)
  {
    result r (db->query&lt;person> (q));
    ...
  }
  </pre>

  <p>At the low level, queries can be written as predicates using
     the database system-native query language such as the
     <code>WHERE</code> predicate from the SQL <code>SELECT</code>
     statement. This language will be refered to as native query
     language. At this level ODB still takes care of converting
     query parameters from C++ to the database system format. Below
     is the re-implementation of the above example using SQL as
     the native query language:</p>

  <pre class="c++">
  query q ("first = 'John' AND age = " + query::_ref (age));
  </pre>

  <p>Note that at this level you also loose the static typing of
     query expressions. For example, if we wrote something like this:</p>

  <pre class="c++">
  query q (query::first == 123 &amp;&amp; query::agee &lt; query::_ref (age));
  </pre>

  <p>We would get two errors during the C++ compilation. The first would
     indicate that we cannot compare <code>query::first</code> to an
     integer and the second would pick the misspelling in
     <code>query::agee</code>. On the other hand, if we wrote something
     like this:</p>

  <pre class="c++">
  query q ("first = 123 AND agee = " + query::_ref (age));
  </pre>

  <p>It would compile without any errors and would trigger an error
     only when executed by the the database system.</p>

  <p>You are also allowed to combine the two query languages in a single
     query, for example:</p>

  <pre class="c++">
  query q ("first = 'John'" + (query::age &lt; query::_ref (age)));
  </pre>


  <h2><a name="4.1">4.1 ODB Query Language</a></h2>

  <p>An ODB query is an expression that tell the database system whether
     any given object matches our criteria. As such a query expression
     always evaluates to <code>true</code> or <code>false</code>. At
     the higher lever, an expression consist of other expressions
     combined with logical operators such as <code>&amp;&amp;</code> (AND),
     <code>||</code> (OR), and <code>!</code> (NOT). For example:</p>

  <pre class="c++">
  typedef odb::query&lt;person> query;

  query q (query::first == "John" || query::age == 31);
  </pre>

  <p>At the core of every query expression lie simple expressions which
     involve one or more object data members, values, or parameters. To
     refer to an object member you use an expression such as
     <code>query::first</code> above. The names of members in the
     <code>query</code> class are derived from the names of data members
     in the object class by removing the common member name decorations,
     such as leading and trailing underscores, the <code>m_</code> prefix,
     etc.</p>

  <p>In a simple expressions an object member can be compared to a value,
     parameter, or another member using a number of predefined operators
     and functions. The following table gives an overview of the available
     expressions:</p>

  <!-- border="1" is necessary for html2ps -->
  <table id="operators" border="1">
    <tr>
      <th>Operator</th>
      <th>Description</th>
      <th>Example</th>
    </tr>

    <tr>
      <td><code>==</code></td>
      <td>equal</td>
      <td><code>query::age == 31</code></td>
    </tr>

    <tr>
      <td><code>!=</code></td>
      <td>unequal</td>
      <td><code>query::age != 31</code></td>
    </tr>

    <tr>
      <td><code>&lt;</code></td>
      <td>less than</td>
      <td><code>query::age &lt; 31</code></td>
    </tr>

    <tr>
      <td><code>></code></td>
      <td>greater than</td>
      <td><code>query::age > 31</code></td>
    </tr>

    <tr>
      <td><code>&lt;=</code></td>
      <td>less than or equal</td>
      <td><code>query::age &lt;= 31</code></td>
    </tr>

    <tr>
      <td><code>>=</code></td>
      <td>greater than or equal</td>
      <td><code>query::age >= 31</code></td>
    </tr>

    <tr>
      <td><code>in()</code></td>
      <td>one of the values</td>
      <td><code>query::age.in (30, 32, 34)</code></td>
    </tr>

    <tr>
      <td><code>in_range()</code></td>
      <td>one of the values in range</td>
      <td><code>query::age.in_range (begin, end)</code></td>
    </tr>

    <tr>
      <td><code>is_null()</code></td>
      <td>value is NULL</td>
      <td><code>query::age.is_null ()</code></td>
    </tr>

    <tr>
      <td><code>is_not_null()</code></td>
      <td>value is not NULL</td>
      <td><code>query::age.is_not_null ()</code></td>
    </tr>
  </table>

  <p>The operator precedence in the query expressions are the same
     as for equivalent C++ operators. You can use parentheses to
     make sure the expression is evaluated in the desired order.
     For example:</p>

  <pre class="c++">
  query q ((query::first == "John" || query::first == "Jane") &amp;&amp;
           query::age &lt; 31);
  </pre>



  <h2><a name="4.2">4.2 Parameter Binding</a></h2>

  <p>An instance of the <code>odb::query</code> class encapsulates two
     parts of information about the query: the query expression and
     the query parameters. Parameters can be bound to C++ variables
     either by value or by reference.</p>

  <p>If a parameter is bound by value, then the value for this parameter
     is copied from the C++ variable to the query instance at the query
     construction time. On the other hand, if a parameter is bound by
     reference, then the query instance only stores a reference to the
     bound variable. The actual value for the parameter is only extracted
     at the query execution time. Consider, for example the following
     two queries:</p>

  <pre class="c++">
  string name ("John");

  query q1 (query::first == query::_val (name));
  query q2 (query::first == query::_ref (name));

  name = "Jane";

  db->query&lt;person> (q1); // Find John.
  db->query&lt;person> (q2); // Find Jane.
  </pre>

  <p>The <code>odb::query</code> class provides two special functions,
     <code>_val()</code> and <code>_ref()</code>, that allow you to
     bind the parameter either by value or by reference, respectively.
     In the embedded query language, if the binding is not specified
     explicitly, the value semantics is used by default. In the
     native query language, binding must always be specified
     explicitly. For example:</p>

  <pre class="c++">
  query q1 (query::age &lt; age);                // By value.
  query q2 (query::age &lt; query::_val (age));  // By value.
  query q3 (query::age &lt; query::_ref (age));  // By reference.

  query q4 ("age &lt; " + age);                  // Error.
  query q5 ("age &lt; " + query::_val (age));    // By value.
  query q6 ("age &lt; " + query::_ref (age));    // By reference.
  </pre>

  <p>A query that only has by-value parameters does not depend on any
     other variables and is self-sufficient once constructed. A query
     that has one or more by-reference parameter depends on the
     bound variables until the query is executed. If one such variable
     goes out of scope and you execute the query, the behavior is
     undefined.</p>

  <h2><a name="4.3">4.3 Executing a Query</a></h2>

  <p>Once we have the query instance ready and by-reference parameters
     initialized, we can execute the query using the
     <code>database::query()</code> function template. It has two
     overloaded variants:</p>

  <pre class="c++">
  template &lt;typename T>
  result&lt;T>
  query (bool cache = true);

  template &lt;typename T>
  result&lt;T>
  query (const odb::query&lt;T>&amp;, bool cache = true);
  </pre>

  <p>The first variant is used to return all persistent objects of a
     given type stored in the database. The second variant uses the
     passed query instance to only return objects matching the
     query criteria. The <code>cache</code> argument determines
     whether the object states should be cached in the application's
     memory or if it should be returned by the database system
     one by one as the iteration over the result progresses. The
     result caching is discussed in detail in the next section.</p>

  <p>When calling the <code>query()</code> function we have to
     explicitly specify the object type we are querying. For example:</p>

  <pre class="c++">
  typedef odb::query&lt;person> query;
  typedef odb::result&lt;person> result;

  result all (db->query&lt;person> ());
  result johnes (db->query&lt;person> (query::first == "John"));
  </pre>

  <p>Note that it is not required to explicitly create a named
     query variable before executing it. For example, the following
     two queries are equivalent:</p>

  <pre class="c++">
  query q (query::first == "John");

  result r1 (db->query&lt;person> (q));
  result r1 (db->query&lt;person> (query::first == "John"));
  </pre>

  <p>Normally you would create a named query instance if you are
     planning to run the same query multiple times and would use the
     in-line version for those that are executed only once.</p>

  <p>It is also possible to create queries from other queries by
     combinding them using logical operators. For example:</p>

  <pre class="c++">
result
find_minors (database&amp; db, const query&amp; name_query)
{
  return db.query&lt;person> (name_query &amp;&amp; query::age &lt; 18);
}

result r (find_underage (db, query::first == "John"));
  </pre>

  <h2><a name="4.3">4.3 Query Result</a></h2>

  <p>The result of executing a query is zero, one, or more objects
     matching the query criteria. The result is represented as the
     <code>odb::result</code> class template:</p>

  <pre class="c++">
  typedef odb::query&lt;person> query;
  typedef odb::result&lt;person> result;

  result johnes (db->query&lt;person> (query::first == "John"));
  </pre>

  <p>It is best to view an instance of <code>odb::result</code>
     as a handle to a stream, such as a file stream. While you can
     make a copy of a result or assign one result to another, the
     two instances will refer to the same result stream. Advancing
     the current position in one instance will also advance it in
     another. The result instance is only usable within a transaction
     it was created in. Trying to manipulate the result after the
     transaction has terminates leads to undefined behavior.</p>

  <p>The <code>odb::result</code> class template conforms to the
     standard C++ sequence requirements and has the following
     interface:</p>

  <pre class="c++">
namespace odb
{
  template &lt;typename T>
  class result
  {
  public:
    typedef odb::result_iterator&lt;T> iterator;

  public:
    result ();

    result (const result&amp;);

    result&amp;
    operator= (const result&amp;);

    void
    cache ();

    iterator
    begin ();

    iterator
    end ();
  };
}
  </pre>

  <p>The default constructor creates an empty result set. The
    <code>cache()</code> function caches the returned objects'
    state in the application's memory. We have already mentioned
    result caching when we talked about query execution. As you
    may remember the <code>database::query()</code> function
    cahces the result unless instructed not to by the caller.
    The <code>result::cache()</code> function allows you to
    cache the result at a later stage if it wasn't already
    cached during query execution.</p>

  <p>If result is cached, the entire state of the returned
     objects is stored in the application's memory. Note that
     the actual objects are still only instantiated on demand
     during result iteration. It is the raw database state that
     is cached in memory. In contrast, for uncached results
     the object state is sent by the database system one object
     at a time as the iteration progresses.</p>

  <p>Uncached results can improve performance of both the application
     and the database system in situations where you have a large
     number of objects in the result or if you will only examine
     a small portion of the returned objects. However, uncached
     results have a number of limitations. There can only be one
     uncached result in a transaction. Creating another result
     (cached or uncached) by calling <code>database::query()</code>
     will invalidate the first uncached result. Furthermore,
     executing any other database function, such as <code>update()</code>
     or <code>erase()</code> will also invalidate the uncached result.</p>

  <p>To iterate over the objects in a result we use the
     <code>begin()</code> and <code>end()</code> functions
     together with the <code>odb::result&lt;T>::iterator</code>
     type, for example:</p>

  <pre class="c++">
  result r (db->query&lt;person> (query::first == "John"));

  for (result::iterator i (r.begin ()); i != r.end (); ++i)
  {
    ...
  }
  </pre>

  <p>The result iterator is an input iterator which means that the
     only two position operations that are support are to move to the
     next object and determine whether we have reached the end of the
     result stream. In fact, the result iteraror can only be in two
     states: the current position and the end position. If you have
     two iterators pointing to the current position and then you
     advance one of them, the other will advance as well. This,
     for example, means that it doesn't make sense to store an
     iterator that points to some object of interest in the result
     stream with the intent of dereferncing it after the iteration
     is over. Instead, you would need to store the object itself.</p>

  <p>The result iterator has the following dereference functions
     that can be used to access the pointed-to object:</p>

  <pre class="c++">
namespace odb
{
  template &lt;typename T>
  class result_iterator
  {
  public:
    T*
    operator-> () const;

    T&amp;
    operator* () const;

    typename object_traits&lt;T>::pointer_type
    load ();

    void
    load (T&amp; x);
  };
}
  </pre>

  <p>When you call the <code>*</code> or <code>-></code> operator,
     the iterator will allocate a new instance of the object class
     in the dynamic memory, load its state from the returned database
     state, and return a reference or pointer to the new instance. The
     iterator maintains the ownership of the returned object and will
     return the same pointer for subsequent calls to either of these
     operators until it is advanced to the next object or you call
     the first overloaded variant of the <code>load()</code>
     function (see below). For example:</p>

  <pre class="c++">
  result r (db->query&lt;person> (query::first == "John"));

  for (result::iterator i (r.begin ()); i != r.end ();)
  {
    cout &lt;&lt; i->last () &lt;&lt; endl; // Create an object.
    person&amp; p (*i);             // Reference to the same object.
    cout &lt;&lt; p.age () &lt;&lt; endl;
    ++i;                        // Free the object.
  }
  </pre>

  <p>The <code>result_iterator::load()</code> function is similar to
     <code>database::load()</code>. The first overloaded variant
     returns a dynamically allocated instance of the current
     object which you are responsible for deleting. As an optimization,
     if the iterator already owns an object as result of the earlier
     call to the <code>*</code> or <code>-></code> operator, then it
     relinquishes the ownership of this object and returns it instead.
     This allows you to write code like this without worrying about
     a double allocation:</p>

  <pre class="c++">
  result r (db->query&lt;person> (query::first == "John"));

  for (result::iterator i (r.begin ()); i != r.end (); ++i)
  {
    if (i->last == "Doe")
    {
      auto_ptr p (i.load ());
      ...
    }
  }
  </pre>

  <p>Note, however, that because of this optimization, a subsequent to
     <code>load()</code> call to the <code>*</code> or <code>-></code>
     operator results in the allocation of a new object.</p>

  <p>The second variant of the <code>result_iterator::load()</code>
     function allows you to load the current object's state into an
     existing instance. For example:</p>

  <pre class="c++">
  result r (db->query&lt;person> (query::first == "John"));

  person p;
  for (result::iterator i (r.begin ()); i != r.end (); ++i)
  {
    i.load (p);
    cout &lt;&lt; p.last () &lt;&lt; endl;
    cout &lt;&lt; i.age () &lt;&lt; endl;
  }
  </pre>


  <!-- CHAPTER -->


  <h1><a name="5">5 ODB Pragma Language</a></h1>

  <p>As we have already seen in previous chapters, ODB uses a pragma-based
     language to capture database-specific information about C++ types.
     This chapter describes the ODB pragma language in more detail. It
     can be read together with other chapters in the manual to get a
     sense of what kind configurations and mapping fine-tuning are
     possible. You can also use this chapter as a reference at a later
     stage.</p>

  <p>An ODB pragma has the following syntax:</p>

  <p><code>#pragma db <i>qualifier</i> [<i>specifier</i> <i>specifier</i> ...]</code></p>

  <p>The qualifier tell the ODB compiler what kind of C++ construct
     this pragma describes. Valid qualifiers are <code>object</code>,
     <code>value</code>, and <code>member</code>. Pragmas with the
     <code>object</code> qualifier describes persistent object types.
     It tells the ODB compiler that a C++ class it describes is a
     persistent class. Similarly, pragmas with the <code>value</code>
     qualifier describes value types and the <code>member</code>
     qualfier is used to describe data members of persistent object
     and value types.</p>

  <p>The specifier informs the ODB compiler about a particular property
     of the C++ declaration. For example, the <code>id</code> member
     specifier tell the ODB compiler that this member contains this
     object's identifier. Below is the declaration of the <code>person</code>
     class that shows how we can use these qualifiers and specifiers:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...
private:
  #pragma db member id
  unsigned long id_;
  ...
};
  </pre>

  <p>In the above example we don't explicitly specify which C++ class or
     data member the pragma belongs to. Rather, the pragma applies to
     a C++ declaration that immediately follows the pragma. Such pragmas
     are called <em>positioned pragmas</em>. In positioned pragmas that
     apply to data members the <code>member</code> qualifier can be
     omitted for brievety, for example:</p>

  <pre class="c++">
  #pragma db id
  unsigned long id_;
  </pre>

  <p>Note also that if the C++ declaration immediately following a
     position pragma is incompatible with the pragma qualifier, an
     error will be issued. For example:</p>

  <pre class="c++">
  #pragma db object  // Error: expected class instead of data member.
  unsigned long id_;
  </pre>


  <p>While keeping the C++ declarations and database declarations close
     together eases maintenance and increases readability, you can also
     separate them in different parts of the same header file or even
     factor them to a seperate file. To achive this we use the so called
     <em>named pragmas</em>. Unlike positioned pragmas, named pragmas
     explicitly specify the C++ declaration to which they apply by
     adding the declaration name after the pragma qualifier. For example:</p>

  <pre class="c++">
class person
{
  ...
private:
  unsigned long id_;
  ...
};

#pragma db object(person)
#pragma db member(person::id_) id
  </pre>

  <p>Note that in the named pragmas for data members the <code>member</code>
     qualifier is no longer optional. The C++ declaration name in the
     named pragmas is resolved using the standard C++ name resolution
     rules, for example:</p>

  <pre class="c++">
namespace db
{
  class person
  {
    ...
  private:
    unsigned long id_;
    ...
  };
}

namespace db
{
  #pragma db object(person)  // Resolves db::person.
}

#pragma db member(db::person::id_) id
  </pre>

  <p>The following code fragment shows how to use the named value
     type pragma to map a C++ type to a native database type:</p>

  <pre class="c++">
#pragma db value(bool) type("INT NOT NULL")

#pragma db object
class person
{
  ...
private:
  bool married_; // Mapped to INT NOT NULL database type.
  ...
};
  </pre>

  <h2><a name="5.1">5.1 C++ Compiler Warnings</a></h2>

  <p>The C++ header file that defines your persistent classes and
     normally contains one or more ODB pragmas is compiled by both
     the ODB compiler to generate the database support code and
     the C++ compiler to build your application. Some C++ compilers
     issue warnings about pragmas that they do not recognize. There
     are several ways to deal with this problem. The easiest is to
     disable such warnings using one of the compiler-specific command
     line options or warning control pragmas. This method is described
     in the following sub-section for most popular C++ compiler.</p>

  <p>There are also several C++ compiler-independant methods that you
     can employ. The first is to use the <code>PRAGMA_DB</code> macro,
     defined in <code>&lt;odb/core.hxx></code>, instead of the
     <code>#pragma&nbsp;db</code> directly. This macro expands to the
     ODB pragma when compiled with the ODB compiler and to an empty
     string when compiler with other compilers. The following example
     shows how we can use this macro:</p>

  <pre class="c++">
#include &lt;odb/core.hxx>

PRAGMA_DB(object)
class person
{
  ...
private:
  PRAGMA_DB(id)
  unsigned long id_;
  ...
};
  </pre>

  <p>The alternative to using the <code>PRAGMA_DB</code> macro is to
     group the <code>#pragma&nbsp;db</code> directives in blocks that are
     conditionally included into compilation only when compiled with the
     ODB compiler. For example:</p>

  <pre class="c++">
class person
{
  ...
private:
  unsigned long id_;
  ...
};

#ifdef ODB_COMPILER
#  pragma db object(person)
#  pragma db member(person::id_) id
#endif
  </pre>

  <p>The disadvantage of this approach is that it becomes overly verbose
     when positioned pragmas are used.</p>

  <h3><a name="5.1.1">5.1.1 GNU C++</a></h3>

  <p>GNU g++ does not issue warnings about unknown pragmas
     unless requested with the <code>-Wall</code> command line option.
     To disable only the unknown pragma warning you can add the
     <code>-Wno-unknown-pragmas</code> option after <code>-Wall</code>,
     for example:</p>

  <pre class="terminal">
g++ -Wall -Wno-unknown-pragmas ...
  </pre>

  <h3><a name="5.1.2">5.1.2 Visual C++</a></h3>

  <p>Microsoft Visual C++ issues an unknown pragma warning (C4068) at
     warning level 1 or higher. This means that unless you have disabled
     warnings altogether (level 0), you will see this warning.</p>

  <p>To disable this warning via the compiler command line, you can add
     the <code>/wd4068</code> C++ compiler option in Visual Studio 2008
     and earlier. In Visual Studio 2010 there is now a special GUI field
     where you can enter warning numbers that should be disabled. Simply
     enter 4068 into this field.</p>

  <p>You can also disable this warning only for a specific header or
     a fragment of a header using the warning control pragma. For
     example:</p>

  <pre class="c++">
#include &lt;odb/core.hxx>

#pragma warning (push)
#pragma warning (disable:4068)

#pragma db object
class person
{
  ...
private:
  #pragma db id
  unsigned long id_;
  ...
};

#pragma warning (pop)
  </pre>

  <h3><a name="5.1.3">5.1.3 Sun C++</a></h3>

  <p>The Sun C++ compiler does not issue warnings about unknown pragmas.
     As a result, no additional actions are required for this compiler.</p>

  <h3><a name="5.1.4">5.1.4 IBM XL C++</a></h3>

  <p>IBM XL C++ issues an unknown pragma warning (1540-1401) by default.
     To disable this warning you can add the <code>-qsuppress=1540-1401</code>
     command line option, for example:</p>

  <pre class="terminal">
xlC -qsuppress=1540-1401 ...
  </pre>


  <h2><a name="5.2">5.2 Object Type Pragmas</a></h2>

  <p>A pragma with the <code>object</code> qualifier declares a C++ class
     as a persistent object type. The qualifier can be optionally followed
     by the <code>table</code> specifier.</p>

  <h3><a name="5.2.1">5.2.1 <code>table</code></a></h3>

  <p>The <code>table</code> specifier specifies the table name that should
     be used to store objects of this class in a relational database. For
     example:</p>

  <pre class="c++">
#pragma db object table("people")
class person
{
  ...
};
  </pre>

  <p>If the table name is not specified, the class name is used as the
     default.</p>

  <h2><a name="5.3">5.3 Value Type Pragmas</a></h2>

  <p>A pragma with the <code>value</code> qualifier describes a value
     type and can be optionally followed by the <code>type</code>
     specifier.</p>

  <h3><a name="5.3.1">5.3.1 <code>type</code></a></h3>

  <p>The <code>type</code> specifier specifies the native database type
     that should be used for data members of this type. For example:</p>

  <pre class="c++">
#pragma db value(bool) type("INT NOT NULL")

#pragma db object
class person
{
  ...
private:
  bool married_; // Mapped to INT NOT NULL database type.
  ...
};
  </pre>

  <p>The ODB compiler includes the default mapping between common C++
     types, such as <code>bool</code>, <code>int</code>, and
     <code>std::string</code> and the database types for each supported
     database system. For more information on the default mapping,
     refer to (@@ ref Database Systems).</p>

  <p>In the above example we changed the mapping for the <code>bool</code>
     type which is now mapped to the <code>INT</code> database type. In
     this case the <code>value</code> pragma is all that is necessary
     since the ODB compiler will be able to figure out how to store
     a boolean value as an integer in the database. However, there
     could be situations where the ODB compiler will not know how to
     handle the conversion between the C++ and database representations
     of a value. Consider, as an example, a situation where the
     boolean value is stored in the database as a string:</p>

  <pre class="c++">
#pragma db value(bool) type("VARCHAR(5) NOT NULL")
  </pre>

  <p>The possible database value for the C++ <code>true</code> value could
     be <code>"true"</code>, or <code>"TRUE"</code>, or <code>"True"</code>.
     Or, maybe, all of the above are valid. The ODB compiler has no way
     of knowing how your application wants to convert <code>bool</code>
     to a string and back.</p>

  <p>@@ value_type straits specialization example.</p>

  <p>It is also possible to change the database type mapping for individual
     members, as discussed in (@@ ref member type specifier).</p>

  <h2><a name="5.4">5.4 Data Member Pragmas</a></h2>

  <p>A pragma with the <code>member</code> qualifier or a positioned
     pragma without a qualifier describes a data member. It can
     be optionally followed, in any order, by the specifiers summarized
     in the table below:</p>

  <!-- border="1" is necessary for html2ps -->
  <table id="specifiers" border="1">
    <tr>
      <th>Specifier</th>
      <th>Summary</th>
      <th>Section</th>
    </tr>

    <tr>
      <td><code>id</code></td>
      <td>the member is an object id</td>
      <td><a href="#5.4.1">5.4.1</a></td>
    </tr>

    <tr>
      <td><code>auto</code></td>
      <td>id is assigned by the database</td>
      <td><a href="#5.4.2">5.4.2</a></td>
    </tr>

    <tr>
      <td><code>type</code></td>
      <td>the database type for the member</td>
      <td><a href="#5.4.3">5.4.3</a></td>
    </tr>

    <tr>
      <td><code>column</code></td>
      <td>the column name for the member</td>
      <td><a href="#5.4.4">5.4.4</a></td>
    </tr>

    <tr>
      <td><code>transient</code></td>
      <td>the member is not stored in the database</td>
      <td><a href="#5.4.5">5.4.5</a></td>
    </tr>

  </table>

  <h3><a name="5.4.1">5.4.1 <code>id</code></a></h3>

  <p>The <code>id</code> specifier specifies that the data member contains
     the object id. Every persistent class must have a member designated
     as an object identifier. For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...
private:
  #pragma db id
  std::string email_;
  ...
};
  </pre>

  <p>In a relational database, an identifier member is mapped to a
     primary key.</p>

  <h3><a name="5.4.2">5.4.2 <code>auto</code></a></h3>

  <p>The <code>auto</code> specifier specifies that the object identifier
     is automatically assigned by the database. Only a member that was
     designated as an object identifier can have this specifier. For
     example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...
private:
  #pragma db id auto
  unsigned long id_;
  ...
};
  </pre>

  <p>Note that automatically-assigned object identifiers are not reused.
     If you have a high object turnover (that is, objects are routinely
     made persistent and then erased), then care must be taken not to
     run out of object identifiers. In such situations using
     <code>unsigned long long</code> as the identifier type is a safe
     choice.</p>

  <p>For additional information on the automatic identifier assignment,
     refer to (@@ ref persist() function).</p>

  <h3><a name="5.4.3">5.4.3 <code>type</code></a></h3>

  <p>The <code>type</code> specifier specifies the native database type
     that should be used for this data member. For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...
private:
  #pragma db type("INT NOT NULL")
  bool married_;
  ...
};
  </pre>

  <p>The behavior of this specifier for members is similar to that
     for value types. The only difference is the scope. The value
     type pragma applies to all members with this value type that
     don't have their own <code>type</code> specifiers. While the
     member pragma applies only to a single member. For more
     information on the semantics of this specifier refer to
     the (@@ ref value type "value" specifier).</p>

  <h3><a name="5.4.4">5.4.4 <code>column</code></a></h3>

  <p>The <code>column</code> specifier specifies the column name
     that should be used to store this member in a relational database.
     For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...
private:
  #pragma db id column("person_id")
  unsigned long id_;
  ...
};
  </pre>

  <p>If the column name is not specified, it is derived from the member
     name by removing the common member name decorations, such as leading
     and trailing underscores, the <code>m_</code> prefix, etc.</p>

  <h3><a name="5.4.5">5.4.5 <code>transient</code></a></h3>

  <p>The <code>transient</code> specifier instructs the ODB compiler
     not to store the data member in the database. For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...
private:
  date born_;

  #pragma db transient
  unsigned short age_; // Computed from born_.
  ...
};
  </pre>

  <p>This pragma is usualy used on computed members, pointers and
     references that are only meaningful in the application's
     memory, as well as utility members such as mutexes, etc.</p>


  <!-- CHAPTER -->


  <h1><a name="6">6 Database Systems</a></h1>

  <p>This chapter covers topics specific to the database system
     implementations and their support in ODB. In particular, it
     describes the system-specific <code>database</code> classes
     as well as the default mapping between basic C++ value types
     and native database types.</p>


  <h2><a name="6.1">6.1 MySQL Database</a></h2>

  <p>To generate support code for the MySQL database you will need
     to pass the "<code>--database&nbsp;mysql</code>"
     (or "<code>-d&nbsp;mysql</code>") option to the ODB compiler.
     Your application will also need to link to the ODB MySQL runtime
     library (<code>libodb-mysql</code>). All MySQL-specific ODB
     classes are defined in the <code>odb::mysql</code> namespace.</p>

  <h3><a name="6.1.1">6.1.1 MySQL Type Mapping</a></h3>

  <p>The following table summarizes the default mapping between basic
     C++ value types and MySQL database types. This mapping can be
     customized on the per-type and per-member basis using ODB pragmas
     (@@ ref ODB Pragma language).</p>

  <!-- border="1" is necessary for html2ps -->
  <table id="mapping" border="1">
    <tr>
      <th>C++ Type</th>
      <th>MySQL type</th>
    </tr>

    <tr>
      <td><code>bool</code></td>
      <td><code>TINYINT(1) NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>char</code></td>
      <td><code>TINYINT NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>signed char</code></td>
      <td><code>TINYINT NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>unsigned char</code></td>
      <td><code>TINYINT UNSIGNED NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>short</code></td>
      <td><code>SMALLINT NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>unsigned short</code></td>
      <td><code>SMALLINT UNSIGNED NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>int</code></td>
      <td><code>INT NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>unsigned int</code></td>
      <td><code>INT UNSIGNED NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>long</code></td>
      <td><code>BIGINT NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>unsigned long</code></td>
      <td><code>BIGINT UNSIGNED NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>long long</code></td>
      <td><code>BIGINT NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>unsigned long long</code></td>
      <td><code>BIGINT UNSIGNED NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>float</code></td>
      <td><code>FLOAT NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>double</code></td>
      <td><code>DOUBLE NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>std::string</code></td>
      <td><code>TEXT NOT NULL/VARCHAR(255) NOT NULL</code></td>
    </tr>
  </table>

  <p>Note that the <code>std::string</code> type is mapped
     differently depending on whether the member of this type
     is an object id or not. If the member is an object id,
     then for this member <code>std::string</code> is mapped
     to <code>VARCHAR(255) NOT NULL</code> MySQL type. Otherwise
     it is mapped to <code>TEXT NOT NULL</code>.</p>

  <h3><a name="6.1.2">6.1.2 MySQL Database Class</a></h3>

  <p>The MySQL <code>database</code> class has the following
     interface:</p>

  <pre class="c++">
namespace odb
{
  namespace mysql
  {
    class database: public odb::database
    {
    public:
      database (const char* user,
                const char* passwd,
                const char* db,
                const char* host = 0,
                unsigned int port = 0,
                const char* socket = 0,
                unsigned long client_flags = 0,
                std::auto_ptr&lt;connection_factory> = 0);

      database (const std::string&amp; user,
                const std::string&amp; passwd,
                const std::string&amp; db,
                const std::string&amp; host = "",
                unsigned int port = 0,
                const std::string* socket = 0,
                unsigned long client_flags = 0,
                std::auto_ptr&lt;connection_factory> = 0);

      database (const std::string&amp; user,
                const std::string* passwd,
                const std::string&amp; db,
                const std::string&amp; host = "",
                unsigned int port = 0,
                const std::string* socket = 0,
                unsigned long client_flags = 0,
                std::auto_ptr&lt;connection_factory> = 0);

      database (const std::string&amp; user,
                const std::string&amp; passwd,
                const std::string&amp; db,
                const std::string&amp; host,
                unsigned int port,
                const std::string&amp; socket,
                unsigned long client_flags = 0,
                std::auto_ptr&lt;connection_factory> = 0);

      database (const std::string&amp; user,
                const std::string* passwd,
                const std::string&amp; db,
                const std::string&amp; host,
                unsigned int port,
                const std::string&amp; socket,
                unsigned long client_flags = 0,
                std::auto_ptr&lt;connection_factory> = 0);

      database (int&amp; argc,
                char* argv[],
                bool erase = false,
                unsigned long client_flags = 0,
                std::auto_ptr&lt;connection_factory> = 0);

      static void
      print_usage (std::ostream&amp;);


    public:
      const char*
      user () const;

      const char*
      password () const;

      const char*
      db () const;

      const char*
      host () const;

      unsigned int
      port () const;

      const char*
      socket () const;

      unsigned long
      client_flags () const;

    public:
      details::shared_ptr&lt;mysql::connection>
      connection ();
    };
  }
}
  </pre>

  <p>You will need to include the <code>&lt;odb/mysql/database.hxx></code>
     header file to make this class available in your application.</p>

  <p>The overloaded <code>database</code> constructros allow you
     to specify MySQL database parameters that should be used when
     connecting to the database. In MySQL <code>NULL</code> and
     empty string are treated as the same values for all the
     string parameters except password and socket. The
     <code>client_flags</code> argument allows you to specify
     various MySQL client library flags. For more information
     on the possible values, refer to the MySQL C API dicumentation.
     The <code>CLIENT_FOUND_ROWS</code> flag is always set by the
     ODB MySQL runtime regardless of whether it was passed in the
     <code>client_flags</code> argument.</p>

  <p>The last constructor variant extracts the database parameters
     from the command line. The following options are recognized:</p>

  <pre class="terminal">
  --user &lt;login>
  --password &lt;password>
  --database &lt;name>
  --host &lt;host>
  --port &lt;integer>
  --socket &lt;socket>
  --options-file &lt;file>
  </pre>

  <p>The <code>--options-file</code> option allows you to specify some
  or all of the database options in a file with each option appearing
  on a separate line followed by space and an option value.</p>

  <p>If the <code>erase</code> argument to this constructor is true,
     then the above options are removed from the <code>argv</code>
     array and the <code>argc</code> count is updated accordingly.
     This is primarily useful if your application accepts other
     options or arguments and you would like to get the MySQL
     options out of the <code>argv</code> array.</p>

  <p>This constructor throws the <code>odb::mysql::cli_exception</code>
     exception if the MySQL option values are missing or invalid.
     See section (@@ ref MySQL Exceptions) for more information
     on this exception.</p>

  <p>The static <code>print_usage()</code> function allows you
     to print the list of options with short descriptions that
     are recognized by this constructor.</p>

  <p>The last argument to all of the constructor variants is the
     pointer to the connection factory. If you pass a
     non-<code>NULL</code> value, the database instance assumes
     ownership of the connection factory. The connection factory
     interface as well as the available implementations are discussed
     in the next section.</p>

  <p>The set of accessor function following the constructors allows you
     to query the parameters of the <code>database</code> instance.</p>

  <p>The <code>connection()</code> function returns the MySQL database
     connection encapsulated by the <code>odb::mysql::connection</code>
     class. Normally, you wouldn't call this function directly and
     instead let the ODB runtime manage database connections. However,
     if for some reason you need to access the underlying MySQL connection
     handle, refer to the ODB MySQL runtime source code for the interface
     of the <code>connection</code> class.</p>

  <h3><a name="6.1.3">6.1.3 Connection Factory</a></h3>

  <p>The <code>connection_factory</code> abstract class has the
     following interface:</p>

  <pre class="c++">
namespace odb
{
  namespace mysql
  {
    class connection_factory
    {
    public:
      virtual void
      database (mysql::database&amp;) = 0;

      virtual details::shared_ptr&lt;connection>
      connect () = 0;
    };
  }
}
  </pre>

  <p>The <code>database()</code> function is called when a connection
     factory is associated with a database instance. This happens in
     the <code>odb::mysql::database</code> class constructors. The
     <code>connect()</code> function is called whenever a database
     connection is requested.</p>

  <p>The two implementations of the <code>connection_factory</code>
     interface provided by the ODB MySQL runtime are
     the <code>new_connection_factory</code> and
     <code>connection_pool_factory</code>. You will need to include
     the <code>&lt;odb/mysql/connection-factory.hxx></code>
     header file to make the <code>connection_factory</code> interface
     and these implementation classes available in your application.</p>


  <p>The <code>new_connection_factory</code> class creates a new
     connection whenever one is requested. When a connection is no
     longer needed it is released and closed. The
     <code>connection_pool_factory</code> class implements a
     connection pool. It has the following interface:</p>

  <pre class="c++">
namespace odb
{
  namespace mysql
  {
    class connection_pool_factory: public connection_factory
    {
      connection_pool_factory (std::size_t max_connections = 0,
                               std::size_t min_connections = 0)
    };
};
  </pre>

  <p>The <code>max_connections</code> argument specifies the maximum
     number and the of concurrent connections this pool factory will
     maintain. Similarly, the <code>min_connections</code> argument
     specifies the minimum number of available connections that
     should be kept open.</p>

  <p>Whenever a connection is requested, the pool factory first
     checks if there is an unused connection that can be returned.
     If there is none, the pool factory checks the
     <code>max_connections</code> value to see if a new connection
     can be created. If the total number of connections maintained
     by the pool is less than this value, then a new connection is
     created and returned. Otherwise the calling thread is blocked
     until a connection becomes available.</p>

  <p>When a connection is released, the pool factory first checks
     if there are blocked threds waiting for a connection. If so,
     one of them is unblocked and is given the connection. Otherwise,
     the pool factory checks whether the total number of connections
     maintained by the pool is greate than the <code>min_connections</code>
     value. If that's the case, the connection is closed. Otherwise the
     connection is added to the pool of available connections to be
     returned on the next request. In other words, if the number of
     connections maintained by the pool exceeds the <code>min_connections</code>
     number and there are no threads waiting for a new connection,
     then the pool will release the excess connections.</p>

  <p>If <code>max_connections</code> value is 0 then the pool will
     create a new connection whenever all of the existing connections
     are in use.  If the <code>min_connections</code> value is 0 then
     the pool will never close a connection and instead maintain all
     the connections that were ever created.</p>

  <p>If you pass <code>NULL</code> as the connection factory to
     one of the <code>database</code> constructors, then the
     <code>connection_pool_factory</code> instance will be
     created by default with the min and max connections values
     set to 0. The following code fragment shows how we can
     pass our own connection factory instance:</p>

  <pre class="c++">
#include &lt;odb/database.hxx>

#include &lt;odb/mysql/database.hxx>
#include &lt;odb/mysql/connection-factory.hxx>

int
main (int argc, char* argv[])
{
  auto_ptr&lt;odb::mysql::connection_factory> f (
    new odb::mysql::connection_pool_factory (20));

  auto_ptr&lt;odb::database> db (
    new mysql::database (argc, argv, false, 0, f));
}
  </pre>

  <h3><a name="6.1.4">6.1.4 MySQL Exceptions</a></h3>

  <p>The ODB MySQL runtime library defines the following MySQL-specific
     exceptions:</p>

  <pre class="c++">
namespace odb
{
  namespace mysql
  {
    class database_exception: odb::database_exception
    {
    public:
      unsigned int
      error () const;

      const std::string&amp;
      sqlstate () const;

      const std::string&amp;
      message () const;

      virtual const char*
      what () const throw ();
    };

    class cli_exception: odb::exception
    {
    public:
      virtual const char*
      what () const throw ();
    };
  }
}
  </pre>

  <p>You will need to include the <code>&lt;odb/mysql/exceptions.hxx></code>
     header file to make these exceptions available in your application.</p>

  <p>The <code>odb::mysql::database_exception</code> is thrown if
     a MySQL database operation fails. The MySQL-specific error
     information is accessible via the <code>error()</code>,
     <code>sqlstate()</code>, and <code>message()</code> functions.
     All this information is also cobined and returned in
     human-readable form by the <code>what()</code> function.</p>

  <p>The <code>odb::mysql::cli_exception</code> is thrown by the
     command line parsing constructor of the <code>odb::mysql::database</code>
     class if the MySQL option values are missing or invalid. The
     <code>what()</code> function provides human-readable descriprion
     of an error.</p>

  </div>
</div>


</body>
</html>
