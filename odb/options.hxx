// This code was generated by CLI, a command line interface
// compiler for C++.
//

#ifndef ODB_OPTIONS_HXX
#define ODB_OPTIONS_HXX

#include <deque>
#include <iosfwd>
#include <string>
#include <exception>

namespace cli
{
  class unknown_mode
  {
    public:
    enum value
    {
      skip,
      stop,
      fail
    };

    unknown_mode (value v);

    operator value () const 
    {
      return v_;
    }

    private:
    value v_;
  };

  // Exceptions.
  //

  class exception: public std::exception
  {
    public:
    virtual void
    print (std::ostream&) const = 0;
  };

  std::ostream&
  operator<< (std::ostream&, const exception&);

  class unknown_option: public exception
  {
    public:
    virtual
    ~unknown_option () throw ();

    unknown_option (const std::string& option);

    const std::string&
    option () const;

    virtual void
    print (std::ostream&) const;

    virtual const char*
    what () const throw ();

    private:
    std::string option_;
  };

  class unknown_argument: public exception
  {
    public:
    virtual
    ~unknown_argument () throw ();

    unknown_argument (const std::string& argument);

    const std::string&
    argument () const;

    virtual void
    print (std::ostream&) const;

    virtual const char*
    what () const throw ();

    private:
    std::string argument_;
  };

  class missing_value: public exception
  {
    public:
    virtual
    ~missing_value () throw ();

    missing_value (const std::string& option);

    const std::string&
    option () const;

    virtual void
    print (std::ostream&) const;

    virtual const char*
    what () const throw ();

    private:
    std::string option_;
  };

  class invalid_value: public exception
  {
    public:
    virtual
    ~invalid_value () throw ();

    invalid_value (const std::string& option,
                   const std::string& value);

    const std::string&
    option () const;

    const std::string&
    value () const;

    virtual void
    print (std::ostream&) const;

    virtual const char*
    what () const throw ();

    private:
    std::string option_;
    std::string value_;
  };

  class eos_reached: public exception
  {
    public:
    virtual void
    print (std::ostream&) const;

    virtual const char*
    what () const throw ();
  };

  class file_io_failure: public exception
  {
    public:
    virtual
    ~file_io_failure () throw ();

    file_io_failure (const std::string& file);

    const std::string&
    file () const;

    virtual void
    print (std::ostream&) const;

    virtual const char*
    what () const throw ();

    private:
    std::string file_;
  };

  class unmatched_quote: public exception
  {
    public:
    virtual
    ~unmatched_quote () throw ();

    unmatched_quote (const std::string& argument);

    const std::string&
    argument () const;

    virtual void
    print (std::ostream&) const;

    virtual const char*
    what () const throw ();

    private:
    std::string argument_;
  };

  class scanner
  {
    public:
    virtual
    ~scanner ();

    virtual bool
    more () = 0;

    virtual const char*
    peek () = 0;

    virtual const char*
    next () = 0;

    virtual void
    skip () = 0;
  };

  class argv_scanner: public scanner
  {
    public:
    argv_scanner (int& argc, char** argv, bool erase = false);
    argv_scanner (int start, int& argc, char** argv, bool erase = false);

    int
    end () const;

    virtual bool
    more ();

    virtual const char*
    peek ();

    virtual const char*
    next ();

    virtual void
    skip ();

    private:
    int i_;
    int& argc_;
    char** argv_;
    bool erase_;
  };

  class argv_file_scanner: public argv_scanner
  {
    public:
    argv_file_scanner (int& argc,
                       char** argv,
                       const std::string& file_option,
                       bool erase = false);

    argv_file_scanner (int start,
                       int& argc,
                       char** argv,
                       const std::string& file_option,
                       bool erase = false);

    virtual bool
    more ();

    virtual const char*
    peek ();

    virtual const char*
    next ();

    virtual void
    skip ();

    private:
    void
    load (const char* file);

    typedef argv_scanner base;

    const std::string option_;
    std::string hold_;
    std::deque<std::string> args_;
    bool skip_;
  };
}

#include <string>

#include <vector>

#include <odb/database.hxx>

class options
{
  public:

  options (int& argc,
           char** argv,
           bool erase = false,
           ::cli::unknown_mode option = ::cli::unknown_mode::fail,
           ::cli::unknown_mode argument = ::cli::unknown_mode::stop);

  options (int start,
           int& argc,
           char** argv,
           bool erase = false,
           ::cli::unknown_mode option = ::cli::unknown_mode::fail,
           ::cli::unknown_mode argument = ::cli::unknown_mode::stop);

  options (int& argc,
           char** argv,
           int& end,
           bool erase = false,
           ::cli::unknown_mode option = ::cli::unknown_mode::fail,
           ::cli::unknown_mode argument = ::cli::unknown_mode::stop);

  options (int start,
           int& argc,
           char** argv,
           int& end,
           bool erase = false,
           ::cli::unknown_mode option = ::cli::unknown_mode::fail,
           ::cli::unknown_mode argument = ::cli::unknown_mode::stop);

  options (::cli::scanner&,
           ::cli::unknown_mode option = ::cli::unknown_mode::fail,
           ::cli::unknown_mode argument = ::cli::unknown_mode::stop);

  // Option accessors.
  //

  const bool&
  help () const;

  const bool&
  version () const;

  const ::database&
  database () const;

  bool
  database_specified () const;

  const bool&
  generate_schema () const;

  const std::string&
  output_dir () const;

  bool
  output_dir_specified () const;

  const std::string&
  odb_file_suffix () const;

  bool
  odb_file_suffix_specified () const;

  const std::string&
  hxx_suffix () const;

  bool
  hxx_suffix_specified () const;

  const std::string&
  ixx_suffix () const;

  bool
  ixx_suffix_specified () const;

  const std::string&
  cxx_suffix () const;

  bool
  cxx_suffix_specified () const;

  const std::string&
  sql_suffix () const;

  bool
  sql_suffix_specified () const;

  const bool&
  include_with_brackets () const;

  const std::string&
  include_prefix () const;

  bool
  include_prefix_specified () const;

  const std::string&
  guard_prefix () const;

  bool
  guard_prefix_specified () const;

  const std::string&
  options_file () const;

  bool
  options_file_specified () const;

  const bool&
  trace () const;

  const std::string&
  mysql_engine () const;

  bool
  mysql_engine_specified () const;

  // Print usage information.
  //
  static void
  print_usage (::std::ostream&);

  private:
  void
  _parse (::cli::scanner&,
          ::cli::unknown_mode option,
          ::cli::unknown_mode argument);

  public:
  bool help_;
  bool version_;
  ::database database_;
  bool database_specified_;
  bool generate_schema_;
  std::string output_dir_;
  bool output_dir_specified_;
  std::string odb_file_suffix_;
  bool odb_file_suffix_specified_;
  std::string hxx_suffix_;
  bool hxx_suffix_specified_;
  std::string ixx_suffix_;
  bool ixx_suffix_specified_;
  std::string cxx_suffix_;
  bool cxx_suffix_specified_;
  std::string sql_suffix_;
  bool sql_suffix_specified_;
  bool include_with_brackets_;
  std::string include_prefix_;
  bool include_prefix_specified_;
  std::string guard_prefix_;
  bool guard_prefix_specified_;
  std::string options_file_;
  bool options_file_specified_;
  bool trace_;
  std::string mysql_engine_;
  bool mysql_engine_specified_;
};

#include <odb/options.ixx>

#endif // ODB_OPTIONS_HXX
