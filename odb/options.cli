// file      : odb/options.cli
// author    : Boris Kolpackov <boris@codesynthesis.com>
// copyright : Copyright (c) 2009-2011 Code Synthesis Tools CC
// license   : GNU GPL v3; see accompanying LICENSE file

include <string>;
include <vector>;

include <odb/database.hxx>;

class options
{
  //
  // Wrapper options. These are not passed to the plugin.
  //

  bool --help {"Print usage information and exit."};
  bool --version {"Print version and exit."};

  //
  // C++ preprocessor options. Also not passed to the plugin.
  //
  std::vector<std::string> -I
  {
    "<dir>",
    "Add <dir> to the beginning of the list of directories to be searched
     for included header files."
  };

  std::vector<std::string> -D
  {
    "<name>[=<def>]",
    "Define macro <name> with definition <def>. If definition is omitted,
     define <name> to be 1."
  };

  std::vector<std::string> -U
  {
    "<name>",
    "Cancel any previous definitions of macro <name>, either built-in or
     provided with the \cb{-D} option."
  };

  //
  // Plugin options.
  //
  ::database --database | -d
  {
    "<db>",
    "Generate code for the <db> database. Valid values are \cb{mysql} and
     \cb{tracer}."
  };

  bool --generate-query
  {
    "Generate query support code. Without this support you can only
     load objects via their ids."
  };

  bool --generate-schema
  {
    "Generate database schema. The resulting SQL file creates database
     tables required to store classes defined in the file being compiled.
     Note that all the existing information stored in such tables will be
     lost."
  };

  std::string --default-pointer = "*"
  {
    "<ptr>",
    "Use <ptr> as the default pointer for persistent objects. Objects that
     do not  have a pointer assigned with the \cb{pointer} pragma specifier
     will use this pointer by default. The value of this option can be \cb{*}
     which denotes the raw pointer and is the default, or a qualified name
     of a smart pointer class template, for example, \cb{std::auto_ptr}. In
     the latter case, the ODB compiler constructs the object pointer by adding
     a single template argument of the object type to the qualified name, for
     example \cb{std::auto_ptr<object>}. The object pointer is used by the
     ODB runtime to return dynamically allocated instances of the object
     type.

     Except for the raw pointer and the standard smart pointers defined
     in the \cb{<memory>} header file, you are expected to include the
     definition of the default pointer at the beginning of the generated
     header file. There are two common ways to achieve this: you can either
     include the necessary header in the file being compiled or you can use
     the \cb{--hxx-prologue} option to add the necessary \cb{#include}
     directive to the generated code."
  };

  std::string --output-dir | -o
  {
    "<dir>",
    "Write the generated files to <dir> instead of the current directory."
  };

  std::string --odb-file-suffix = "-odb"
  {
    "<suffix>",
    "Use <suffix> instead of the default \cb{-odb} to construct the names
     of the generated C++ files."
  };

  std::string --hxx-suffix = ".hxx"
  {
    "<suffix>",
    "Use <suffix> instead of the default \cb{.hxx} to construct the name of
     the generated C++ header file."
  };

  std::string --ixx-suffix = ".ixx"
  {
    "<suffix>",
    "Use <suffix> instead of the default \cb{.ixx} to construct the name of
     the generated C++ inline file."
  };

  std::string --cxx-suffix = ".cxx"
  {
    "<suffix>",
    "Use <suffix> instead of the default \cb{.cxx} to construct the name of
     the generated C++ source file."
  };

  std::string --sql-suffix = ".sql"
  {
    "<suffix>",
    "Use <suffix> instead of the default \cb{.sql} to construct the name of
     the generated database schema file."
  };

  // Prologues.
  //
  std::vector<std::string> --hxx-prologue
  {
    "<text>",
    "Insert <text> at the beginning of the generated C++ header file."
  };

  std::vector<std::string> --ixx-prologue
  {
    "<text>",
    "Insert <text> at the beginning of the generated C++ inline file."
  };

  std::vector<std::string> --cxx-prologue
  {
    "<text>",
    "Insert <text> at the beginning of the generated C++ source file."
  };

  std::vector<std::string> --sql-prologue
  {
    "<text>",
    "Insert <text> at the beginning of the generated database schema file."
  };

  // Epilogues.
  //
  std::vector<std::string> --hxx-epilogue
  {
    "<text>",
    "Insert <text> at the end of the generated C++ header file."
  };

  std::vector<std::string> --ixx-epilogue
  {
    "<text>",
    "Insert <text> at the end of the generated C++ inline file."
  };

  std::vector<std::string> --cxx-epilogue
  {
    "<text>",
    "Insert <text> at the end of the generated C++ source file."
  };

  std::vector<std::string> --sql-epilogue
  {
    "<text>",
    "Insert <text> at the end of the generated database schema file."
  };

  // Prologue files.
  //
  std::string --hxx-prologue-file
  {
    "<file>",
    "Insert the content of <file> at the beginning of the generated C++
     header file."
  };

  std::string --ixx-prologue-file
  {
    "<file>",
    "Insert the content of <file> at the beginning of the generated C++
     inline file."
  };

  std::string --cxx-prologue-file
  {
    "<file>",
    "Insert the content of <file> at the beginning of the generated C++
     source file."
  };

  std::string --sql-prologue-file
  {
    "<file>",
    "Insert the content of <file> at the beginning of the generated
     database schema file."
  };

  // Epilogue files.
  //
  std::string --hxx-epilogue-file
  {
    "<file>",
    "Insert the content of <file> at the end of the generated C++ header
     file."
  };

  std::string --ixx-epilogue-file
  {
    "<file>",
    "Insert the content of <file> at the end of the generated C++ inline
     file."
  };

  std::string --cxx-epilogue-file
  {
    "<file>",
    "Insert the content of <file> at the end of the generated C++ source
     file."
  };

  std::string --sql-epilogue-file
  {
    "<file>",
    "Insert the content of <file> at the end of the generated database
     schema file."
  };

  // ODB compilation prologue/epilogue.
  //
  std::vector<std::string> --odb-prologue
  {
    "<text>",
    "Compile <text> before the input header file. This option allows you
     to add additional declarations, such as custom traits specializations,
     to the ODB compilation process."
  };

  std::vector<std::string> --odb-epilogue
  {
    "<text>",
    "Compile <text> after the input header file. This option allows you
     to add additional declarations, such as custom traits specializations,
     to the ODB compilation process."
  };

  // Include options.
  //
  bool --include-with-brackets
  {
    "Use angle brackets (<>) instead of quotes (\"\") in the generated
     \cb{#include} directives."
  };

  std::string --include-prefix
  {
    "<prefix>",
    "Add <prefix> to the generated \cb{#include} directive paths."
  };

  std::string --guard-prefix
  {
    "<prefix>",
    "Add <prefix> to the generated header inclusion guards. The prefix is
     transformed to upper case and characters that are illegal in a
     preprocessor macro name are replaced with underscores."
  };

  // The following two options are "fake" in that they are actually handled
  // by argv_file_scanner. We have them here to get the documentation.
  //
  std::string --profile|-p
  {
    "<name>",
    "Specify a profile that should be used during compilation.
     Profile is an options file with the name constructed by appending
     the \cb{.options} suffix to <name>. It is searched for in the
     same set of directories as C++ headers included with the
     \cb{#include <...>} directive (built-in paths plus those specified
     with the \cb{-I} options). The options file is first searched for
     in the directory itself and then in its \cb{odb/} subdirectory. For
     format of the options file refer to the \cb{--options-file} option
     below. You can repeat this option to specify more than one profile."
  };

  std::string --options-file
  {
    "<file>",
    "Read additional options from <file> with each option appearing on a
     separate line optionally followed by space and an option value. Empty
     lines and lines starting with \cb{#} are ignored. Option values can
     be enclosed in double (\cb{\"}) or single (\cb{'}) quotes  to preserve
     leading and trailing whitespaces as well as to specify empty values.
     If the value itself contains trailing or leading quotes, enclose it
     with an extra pair of quotes, for example \cb{'\"x\"'}. Non-leading
     and non-trailing quotes are interpreted as being part of the option
     value.

     The semantics of providing options in a file is equivalent to providing
     the same set of options in the same order on the command line at the
     point where the \cb{--options-file} option is specified except that
     the shell escaping and quoting is not required. You can repeat this
     option to specify more than one options file."
  };

  std::vector<std::string> -x
  {
    "<option>",
    "Pass <option> to the underlying C++ compiler (\cb{g++}). The <option>
     value that doesn't start with \cb{-} is considered the \cb{g++}
     executable name."
  };

  bool -v {"Print the commands executed to run the stages of compilation."};

  bool --trace {"Trace the compilation process."};

  //
  // MySQL-specific options.
  //

  std::string --mysql-engine = "InnoDB"
  {
    "<engine>",
    "Use <engine> instead of the default \cb{InnoDB} in the generated
     database schema file. For more information on the storage engine
     options see the MySQL documentation. If you would like to use the
     database-default engine, pass \cb{default} as the value for this
     option."
  };

  //
  // Undocumented options that are used to pass service information
  // between the frontend and the plugin.
  //
  std::string --svc-file;
};
